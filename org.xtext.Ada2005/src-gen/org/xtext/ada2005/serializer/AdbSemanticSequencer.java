/*
 * generated by Xtext
 */
package org.xtext.ada2005.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.ada2005.adb.AcceptAlternative;
import org.xtext.ada2005.adb.AcceptStatement;
import org.xtext.ada2005.adb.AccessToDataDefinition;
import org.xtext.ada2005.adb.AccessToDataInstance;
import org.xtext.ada2005.adb.AccessToSubprogramDefinition;
import org.xtext.ada2005.adb.AccessTypeDefinition;
import org.xtext.ada2005.adb.AdbPackage;
import org.xtext.ada2005.adb.Allocator;
import org.xtext.ada2005.adb.AnonymousAccessDefinition;
import org.xtext.ada2005.adb.ArrayComponentAssociation;
import org.xtext.ada2005.adb.ArrayTypeDefinition;
import org.xtext.ada2005.adb.AspectClause;
import org.xtext.ada2005.adb.AssignmentStatement;
import org.xtext.ada2005.adb.AsynchronousSelect;
import org.xtext.ada2005.adb.AttributeDesignator;
import org.xtext.ada2005.adb.BlockStatement;
import org.xtext.ada2005.adb.CaseStatement;
import org.xtext.ada2005.adb.CaseStatementAlternative;
import org.xtext.ada2005.adb.Compilation;
import org.xtext.ada2005.adb.CompilationUnit;
import org.xtext.ada2005.adb.ComponentChoiceList;
import org.xtext.ada2005.adb.ComponentClause;
import org.xtext.ada2005.adb.ComponentDeclaration;
import org.xtext.ada2005.adb.ComponentDefinition;
import org.xtext.ada2005.adb.ComponentList;
import org.xtext.ada2005.adb.ConditionalEntryCall;
import org.xtext.ada2005.adb.ConstrainedIndexes;
import org.xtext.ada2005.adb.ContextClause;
import org.xtext.ada2005.adb.DataInstanceDeclaration;
import org.xtext.ada2005.adb.DefiningIdentifierList;
import org.xtext.ada2005.adb.DelayAlternative;
import org.xtext.ada2005.adb.DelayStatement;
import org.xtext.ada2005.adb.DeltaConstraint;
import org.xtext.ada2005.adb.DerivedTypeDefinition;
import org.xtext.ada2005.adb.DigitsConstraint;
import org.xtext.ada2005.adb.DiscreteChoice;
import org.xtext.ada2005.adb.DiscreteChoiceList;
import org.xtext.ada2005.adb.DiscriminantAssociation;
import org.xtext.ada2005.adb.DiscriminantConstraint;
import org.xtext.ada2005.adb.DiscriminantSelectors;
import org.xtext.ada2005.adb.DiscriminantSpecification;
import org.xtext.ada2005.adb.EntityRange;
import org.xtext.ada2005.adb.EntryBarrier;
import org.xtext.ada2005.adb.EntryBody;
import org.xtext.ada2005.adb.EntryBodyFormalPart;
import org.xtext.ada2005.adb.EntryCallAlternative;
import org.xtext.ada2005.adb.EntryDeclaration;
import org.xtext.ada2005.adb.EntryIndexSpecification;
import org.xtext.ada2005.adb.EnumerationTypeDefinition;
import org.xtext.ada2005.adb.ExceptionChoice;
import org.xtext.ada2005.adb.ExceptionDeclaration;
import org.xtext.ada2005.adb.ExceptionHandler;
import org.xtext.ada2005.adb.ExitStatement;
import org.xtext.ada2005.adb.ExplicitRange;
import org.xtext.ada2005.adb.Expression;
import org.xtext.ada2005.adb.ExtendedReturnStatement;
import org.xtext.ada2005.adb.ExtensionAggregate;
import org.xtext.ada2005.adb.Factor;
import org.xtext.ada2005.adb.FixedPointDefinition;
import org.xtext.ada2005.adb.FloatingPointDefinition;
import org.xtext.ada2005.adb.FormalDerivedTypeDefinition;
import org.xtext.ada2005.adb.FormalObjectDeclaration;
import org.xtext.ada2005.adb.FormalPackageActualPart;
import org.xtext.ada2005.adb.FormalPackageAssociation;
import org.xtext.ada2005.adb.FormalPackageDeclaration;
import org.xtext.ada2005.adb.FormalPart;
import org.xtext.ada2005.adb.FormalPrivateTypeDefinition;
import org.xtext.ada2005.adb.FormalSubprogramDeclaration;
import org.xtext.ada2005.adb.FormalTypeDeclaration;
import org.xtext.ada2005.adb.FormalTypeDefinition;
import org.xtext.ada2005.adb.FullDataTypeDeclaration;
import org.xtext.ada2005.adb.FunctionSpecification;
import org.xtext.ada2005.adb.GenericActualPart;
import org.xtext.ada2005.adb.GenericAssociation;
import org.xtext.ada2005.adb.GenericDeclaration;
import org.xtext.ada2005.adb.GenericInstantiation;
import org.xtext.ada2005.adb.GenericItems;
import org.xtext.ada2005.adb.GotoStatement;
import org.xtext.ada2005.adb.Guard;
import org.xtext.ada2005.adb.GuardedAlternative;
import org.xtext.ada2005.adb.IfStatement;
import org.xtext.ada2005.adb.IncompleteTypeDeclaration;
import org.xtext.ada2005.adb.IndexConstraint;
import org.xtext.ada2005.adb.InitializedComponents;
import org.xtext.ada2005.adb.InterfaceList;
import org.xtext.ada2005.adb.InterfaceTypeDefinition;
import org.xtext.ada2005.adb.IterationScheme;
import org.xtext.ada2005.adb.KnownDiscriminantPart;
import org.xtext.ada2005.adb.Label;
import org.xtext.ada2005.adb.LabelisableStatement;
import org.xtext.ada2005.adb.LibraryUnitDeclaration;
import org.xtext.ada2005.adb.LoopParameterSpecification;
import org.xtext.ada2005.adb.LoopStatement;
import org.xtext.ada2005.adb.Membership;
import org.xtext.ada2005.adb.ModClause;
import org.xtext.ada2005.adb.Mode;
import org.xtext.ada2005.adb.ModularTypeDefinition;
import org.xtext.ada2005.adb.Name;
import org.xtext.ada2005.adb.NamedArrayAggregate;
import org.xtext.ada2005.adb.Null;
import org.xtext.ada2005.adb.NullStatement;
import org.xtext.ada2005.adb.NumberDeclaration;
import org.xtext.ada2005.adb.NumericLiteral;
import org.xtext.ada2005.adb.OptConstraint;
import org.xtext.ada2005.adb.OptNullExclusion;
import org.xtext.ada2005.adb.OptVariantPart;
import org.xtext.ada2005.adb.OverridingIndicator;
import org.xtext.ada2005.adb.PackageBody;
import org.xtext.ada2005.adb.PackageBodyStub;
import org.xtext.ada2005.adb.PackageDefinition;
import org.xtext.ada2005.adb.PackageSpecification;
import org.xtext.ada2005.adb.ParameterAndResultProfile;
import org.xtext.ada2005.adb.ParameterAssociation;
import org.xtext.ada2005.adb.ParameterSpecification;
import org.xtext.ada2005.adb.PositionalArrayAggregate;
import org.xtext.ada2005.adb.Pragma;
import org.xtext.ada2005.adb.PragmaArgumentAssociation;
import org.xtext.ada2005.adb.PrimaryName;
import org.xtext.ada2005.adb.PrivateExtensionDeclaration;
import org.xtext.ada2005.adb.PrivateTypeDeclaration;
import org.xtext.ada2005.adb.ProcedureOrEntryCallStatement;
import org.xtext.ada2005.adb.ProcedureSpecification;
import org.xtext.ada2005.adb.ProtectedBody;
import org.xtext.ada2005.adb.ProtectedBodyStub;
import org.xtext.ada2005.adb.ProtectedDefinition;
import org.xtext.ada2005.adb.ProtectedTypeDeclaration;
import org.xtext.ada2005.adb.QualifiedName;
import org.xtext.ada2005.adb.RaiseStatement;
import org.xtext.ada2005.adb.RealRangeSpecification;
import org.xtext.ada2005.adb.RecordComponentAssociationList;
import org.xtext.ada2005.adb.RecordDefinition;
import org.xtext.ada2005.adb.RecordExtensionPart;
import org.xtext.ada2005.adb.RecordTypeDefinition;
import org.xtext.ada2005.adb.Relation;
import org.xtext.ada2005.adb.Renaming;
import org.xtext.ada2005.adb.RequeueStatement;
import org.xtext.ada2005.adb.SelectAlternative;
import org.xtext.ada2005.adb.SelectiveAccept;
import org.xtext.ada2005.adb.SeparateSubunit;
import org.xtext.ada2005.adb.SequenceOfStatements;
import org.xtext.ada2005.adb.SignedIntegerTypeDefinition;
import org.xtext.ada2005.adb.SimpleExpression;
import org.xtext.ada2005.adb.SimpleReturnStatement;
import org.xtext.ada2005.adb.SingleProtectedDeclaration;
import org.xtext.ada2005.adb.StringLiteral;
import org.xtext.ada2005.adb.SubprogramBody;
import org.xtext.ada2005.adb.SubprogramDeclaration;
import org.xtext.ada2005.adb.SubprogramDefault;
import org.xtext.ada2005.adb.SubtypeDeclaration;
import org.xtext.ada2005.adb.SubtypeIndication;
import org.xtext.ada2005.adb.TaskBody;
import org.xtext.ada2005.adb.TaskBodyStub;
import org.xtext.ada2005.adb.TaskDeclaration;
import org.xtext.ada2005.adb.TaskDefinition;
import org.xtext.ada2005.adb.TaskNames;
import org.xtext.ada2005.adb.Term;
import org.xtext.ada2005.adb.TimedEntryCall;
import org.xtext.ada2005.adb.TriggeringAlternative;
import org.xtext.ada2005.adb.UnconstrainedIndexes;
import org.xtext.ada2005.adb.UninitializedComponents;
import org.xtext.ada2005.adb.UnknownDiscriminantPart;
import org.xtext.ada2005.adb.UsePackageClause;
import org.xtext.ada2005.adb.UseTypeClause;
import org.xtext.ada2005.adb.Variant;
import org.xtext.ada2005.adb.VariantPart;
import org.xtext.ada2005.adb.WithClause;
import org.xtext.ada2005.services.AdbGrammarAccess;

@SuppressWarnings("all")
public class AdbSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AdbGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AdbPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AdbPackage.ACCEPT_ALTERNATIVE:
				sequence_AcceptAlternative(context, (AcceptAlternative) semanticObject); 
				return; 
			case AdbPackage.ACCEPT_STATEMENT:
				sequence_AcceptStatement(context, (AcceptStatement) semanticObject); 
				return; 
			case AdbPackage.ACCESS_TO_DATA_DEFINITION:
				sequence_AccessToDataDefinition(context, (AccessToDataDefinition) semanticObject); 
				return; 
			case AdbPackage.ACCESS_TO_DATA_INSTANCE:
				sequence_AccessToDataInstance(context, (AccessToDataInstance) semanticObject); 
				return; 
			case AdbPackage.ACCESS_TO_SUBPROGRAM_DEFINITION:
				sequence_AccessToSubprogramDefinition(context, (AccessToSubprogramDefinition) semanticObject); 
				return; 
			case AdbPackage.ACCESS_TYPE_DEFINITION:
				sequence_AccessTypeDefinition(context, (AccessTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.ALLOCATOR:
				sequence_Allocator(context, (Allocator) semanticObject); 
				return; 
			case AdbPackage.ANONYMOUS_ACCESS_DEFINITION:
				sequence_AnonymousAccessDefinition(context, (AnonymousAccessDefinition) semanticObject); 
				return; 
			case AdbPackage.ARRAY_COMPONENT_ASSOCIATION:
				sequence_ArrayComponentAssociation(context, (ArrayComponentAssociation) semanticObject); 
				return; 
			case AdbPackage.ARRAY_TYPE_DEFINITION:
				sequence_ArrayTypeDefinition(context, (ArrayTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.ASPECT_CLAUSE:
				sequence_AspectClause(context, (AspectClause) semanticObject); 
				return; 
			case AdbPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case AdbPackage.ASYNCHRONOUS_SELECT:
				sequence_AsynchronousSelect(context, (AsynchronousSelect) semanticObject); 
				return; 
			case AdbPackage.ATTRIBUTE_DESIGNATOR:
				sequence_AttributeDesignator(context, (AttributeDesignator) semanticObject); 
				return; 
			case AdbPackage.BLOCK_STATEMENT:
				sequence_BlockStatement(context, (BlockStatement) semanticObject); 
				return; 
			case AdbPackage.CASE_STATEMENT:
				sequence_CaseStatement(context, (CaseStatement) semanticObject); 
				return; 
			case AdbPackage.CASE_STATEMENT_ALTERNATIVE:
				sequence_CaseStatementAlternative(context, (CaseStatementAlternative) semanticObject); 
				return; 
			case AdbPackage.COMPILATION:
				sequence_Compilation(context, (Compilation) semanticObject); 
				return; 
			case AdbPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case AdbPackage.COMPONENT_CHOICE_LIST:
				sequence_ComponentChoiceList(context, (ComponentChoiceList) semanticObject); 
				return; 
			case AdbPackage.COMPONENT_CLAUSE:
				sequence_ComponentClause(context, (ComponentClause) semanticObject); 
				return; 
			case AdbPackage.COMPONENT_DECLARATION:
				sequence_ComponentDeclaration(context, (ComponentDeclaration) semanticObject); 
				return; 
			case AdbPackage.COMPONENT_DEFINITION:
				sequence_ComponentDefinition(context, (ComponentDefinition) semanticObject); 
				return; 
			case AdbPackage.COMPONENT_LIST:
				sequence_ComponentList(context, (ComponentList) semanticObject); 
				return; 
			case AdbPackage.CONDITIONAL_ENTRY_CALL:
				sequence_ConditionalEntryCall(context, (ConditionalEntryCall) semanticObject); 
				return; 
			case AdbPackage.CONSTRAINED_INDEXES:
				sequence_ConstrainedIndexes(context, (ConstrainedIndexes) semanticObject); 
				return; 
			case AdbPackage.CONTEXT_CLAUSE:
				sequence_ContextClause(context, (ContextClause) semanticObject); 
				return; 
			case AdbPackage.DATA_INSTANCE_DECLARATION:
				sequence_DataInstanceDeclaration(context, (DataInstanceDeclaration) semanticObject); 
				return; 
			case AdbPackage.DEFINING_IDENTIFIER_LIST:
				sequence_DefiningIdentifierList(context, (DefiningIdentifierList) semanticObject); 
				return; 
			case AdbPackage.DELAY_ALTERNATIVE:
				sequence_DelayAlternative(context, (DelayAlternative) semanticObject); 
				return; 
			case AdbPackage.DELAY_STATEMENT:
				sequence_DelayStatement(context, (DelayStatement) semanticObject); 
				return; 
			case AdbPackage.DELTA_CONSTRAINT:
				sequence_DeltaConstraint(context, (DeltaConstraint) semanticObject); 
				return; 
			case AdbPackage.DERIVED_TYPE_DEFINITION:
				sequence_DerivedTypeDefinition(context, (DerivedTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.DIGITS_CONSTRAINT:
				sequence_DigitsConstraint(context, (DigitsConstraint) semanticObject); 
				return; 
			case AdbPackage.DISCRETE_CHOICE:
				sequence_DiscreteChoice(context, (DiscreteChoice) semanticObject); 
				return; 
			case AdbPackage.DISCRETE_CHOICE_LIST:
				sequence_DiscreteChoiceList(context, (DiscreteChoiceList) semanticObject); 
				return; 
			case AdbPackage.DISCRIMINANT_ASSOCIATION:
				sequence_DiscriminantAssociation(context, (DiscriminantAssociation) semanticObject); 
				return; 
			case AdbPackage.DISCRIMINANT_CONSTRAINT:
				sequence_DiscriminantConstraint(context, (DiscriminantConstraint) semanticObject); 
				return; 
			case AdbPackage.DISCRIMINANT_SELECTORS:
				sequence_DiscriminantSelectors(context, (DiscriminantSelectors) semanticObject); 
				return; 
			case AdbPackage.DISCRIMINANT_SPECIFICATION:
				sequence_DiscriminantSpecification(context, (DiscriminantSpecification) semanticObject); 
				return; 
			case AdbPackage.ENTITY_RANGE:
				sequence_EntityRange(context, (EntityRange) semanticObject); 
				return; 
			case AdbPackage.ENTRY_BARRIER:
				sequence_EntryBarrier(context, (EntryBarrier) semanticObject); 
				return; 
			case AdbPackage.ENTRY_BODY:
				sequence_EntryBody(context, (EntryBody) semanticObject); 
				return; 
			case AdbPackage.ENTRY_BODY_FORMAL_PART:
				sequence_EntryBodyFormalPart(context, (EntryBodyFormalPart) semanticObject); 
				return; 
			case AdbPackage.ENTRY_CALL_ALTERNATIVE:
				sequence_EntryCallAlternative(context, (EntryCallAlternative) semanticObject); 
				return; 
			case AdbPackage.ENTRY_DECLARATION:
				sequence_EntryDeclaration(context, (EntryDeclaration) semanticObject); 
				return; 
			case AdbPackage.ENTRY_INDEX_SPECIFICATION:
				sequence_EntryIndexSpecification(context, (EntryIndexSpecification) semanticObject); 
				return; 
			case AdbPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.EXCEPTION_CHOICE:
				sequence_ExceptionChoice(context, (ExceptionChoice) semanticObject); 
				return; 
			case AdbPackage.EXCEPTION_DECLARATION:
				sequence_ExceptionDeclaration(context, (ExceptionDeclaration) semanticObject); 
				return; 
			case AdbPackage.EXCEPTION_HANDLER:
				sequence_ExceptionHandler(context, (ExceptionHandler) semanticObject); 
				return; 
			case AdbPackage.EXIT_STATEMENT:
				sequence_ExitStatement(context, (ExitStatement) semanticObject); 
				return; 
			case AdbPackage.EXPLICIT_RANGE:
				sequence_ExplicitRange(context, (ExplicitRange) semanticObject); 
				return; 
			case AdbPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case AdbPackage.EXTENDED_RETURN_STATEMENT:
				sequence_ExtendedReturnStatement(context, (ExtendedReturnStatement) semanticObject); 
				return; 
			case AdbPackage.EXTENSION_AGGREGATE:
				sequence_ExtensionAggregate(context, (ExtensionAggregate) semanticObject); 
				return; 
			case AdbPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case AdbPackage.FIXED_POINT_DEFINITION:
				sequence_FixedPointDefinition(context, (FixedPointDefinition) semanticObject); 
				return; 
			case AdbPackage.FLOATING_POINT_DEFINITION:
				sequence_FloatingPointDefinition(context, (FloatingPointDefinition) semanticObject); 
				return; 
			case AdbPackage.FORMAL_DERIVED_TYPE_DEFINITION:
				sequence_FormalDerivedTypeDefinition(context, (FormalDerivedTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.FORMAL_OBJECT_DECLARATION:
				sequence_FormalObjectDeclaration(context, (FormalObjectDeclaration) semanticObject); 
				return; 
			case AdbPackage.FORMAL_PACKAGE_ACTUAL_PART:
				sequence_FormalPackageActualPart(context, (FormalPackageActualPart) semanticObject); 
				return; 
			case AdbPackage.FORMAL_PACKAGE_ASSOCIATION:
				sequence_FormalPackageAssociation(context, (FormalPackageAssociation) semanticObject); 
				return; 
			case AdbPackage.FORMAL_PACKAGE_DECLARATION:
				sequence_FormalPackageDeclaration(context, (FormalPackageDeclaration) semanticObject); 
				return; 
			case AdbPackage.FORMAL_PART:
				sequence_FormalPart(context, (FormalPart) semanticObject); 
				return; 
			case AdbPackage.FORMAL_PRIVATE_TYPE_DEFINITION:
				sequence_FormalPrivateTypeDefinition(context, (FormalPrivateTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.FORMAL_SUBPROGRAM_DECLARATION:
				sequence_FormalSubprogramDeclaration(context, (FormalSubprogramDeclaration) semanticObject); 
				return; 
			case AdbPackage.FORMAL_TYPE_DECLARATION:
				sequence_FormalTypeDeclaration(context, (FormalTypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.FORMAL_TYPE_DEFINITION:
				sequence_FormalTypeDefinition(context, (FormalTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.FULL_DATA_TYPE_DECLARATION:
				sequence_FullDataTypeDeclaration(context, (FullDataTypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.FUNCTION_SPECIFICATION:
				sequence_FunctionSpecification(context, (FunctionSpecification) semanticObject); 
				return; 
			case AdbPackage.GENERIC_ACTUAL_PART:
				sequence_GenericActualPart(context, (GenericActualPart) semanticObject); 
				return; 
			case AdbPackage.GENERIC_ASSOCIATION:
				sequence_GenericAssociation(context, (GenericAssociation) semanticObject); 
				return; 
			case AdbPackage.GENERIC_DECLARATION:
				sequence_GenericDeclaration(context, (GenericDeclaration) semanticObject); 
				return; 
			case AdbPackage.GENERIC_INSTANTIATION:
				sequence_GenericInstantiation(context, (GenericInstantiation) semanticObject); 
				return; 
			case AdbPackage.GENERIC_ITEMS:
				sequence_GenericItems(context, (GenericItems) semanticObject); 
				return; 
			case AdbPackage.GOTO_STATEMENT:
				sequence_GotoStatement(context, (GotoStatement) semanticObject); 
				return; 
			case AdbPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case AdbPackage.GUARDED_ALTERNATIVE:
				sequence_GuardedAlternative(context, (GuardedAlternative) semanticObject); 
				return; 
			case AdbPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case AdbPackage.INCOMPLETE_TYPE_DECLARATION:
				sequence_IncompleteTypeDeclaration(context, (IncompleteTypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.INDEX_CONSTRAINT:
				sequence_IndexConstraint(context, (IndexConstraint) semanticObject); 
				return; 
			case AdbPackage.INITIALIZED_COMPONENTS:
				sequence_InitializedComponents(context, (InitializedComponents) semanticObject); 
				return; 
			case AdbPackage.INTERFACE_LIST:
				sequence_InterfaceList(context, (InterfaceList) semanticObject); 
				return; 
			case AdbPackage.INTERFACE_TYPE_DEFINITION:
				sequence_InterfaceTypeDefinition(context, (InterfaceTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.ITERATION_SCHEME:
				sequence_IterationScheme(context, (IterationScheme) semanticObject); 
				return; 
			case AdbPackage.KNOWN_DISCRIMINANT_PART:
				sequence_KnownDiscriminantPart(context, (KnownDiscriminantPart) semanticObject); 
				return; 
			case AdbPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case AdbPackage.LABELISABLE_STATEMENT:
				sequence_LabelisableStatement(context, (LabelisableStatement) semanticObject); 
				return; 
			case AdbPackage.LIBRARY_UNIT_DECLARATION:
				sequence_LibraryUnitDeclaration(context, (LibraryUnitDeclaration) semanticObject); 
				return; 
			case AdbPackage.LOOP_PARAMETER_SPECIFICATION:
				sequence_LoopParameterSpecification(context, (LoopParameterSpecification) semanticObject); 
				return; 
			case AdbPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case AdbPackage.MEMBERSHIP:
				sequence_Membership(context, (Membership) semanticObject); 
				return; 
			case AdbPackage.MOD_CLAUSE:
				sequence_ModClause(context, (ModClause) semanticObject); 
				return; 
			case AdbPackage.MODE:
				sequence_Mode(context, (Mode) semanticObject); 
				return; 
			case AdbPackage.MODULAR_TYPE_DEFINITION:
				sequence_ModularTypeDefinition(context, (ModularTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case AdbPackage.NAMED_ARRAY_AGGREGATE:
				sequence_NamedArrayAggregate(context, (NamedArrayAggregate) semanticObject); 
				return; 
			case AdbPackage.NULL:
				sequence_Null(context, (Null) semanticObject); 
				return; 
			case AdbPackage.NULL_STATEMENT:
				sequence_NullStatement(context, (NullStatement) semanticObject); 
				return; 
			case AdbPackage.NUMBER_DECLARATION:
				sequence_NumberDeclaration(context, (NumberDeclaration) semanticObject); 
				return; 
			case AdbPackage.NUMERIC_LITERAL:
				sequence_NumericLiteral(context, (NumericLiteral) semanticObject); 
				return; 
			case AdbPackage.OPT_CONSTRAINT:
				sequence_OptConstraint(context, (OptConstraint) semanticObject); 
				return; 
			case AdbPackage.OPT_NULL_EXCLUSION:
				sequence_OptNullExclusion(context, (OptNullExclusion) semanticObject); 
				return; 
			case AdbPackage.OPT_VARIANT_PART:
				sequence_OptVariantPart(context, (OptVariantPart) semanticObject); 
				return; 
			case AdbPackage.OVERRIDING_INDICATOR:
				sequence_OverridingIndicator(context, (OverridingIndicator) semanticObject); 
				return; 
			case AdbPackage.PACKAGE_BODY:
				sequence_PackageBody(context, (PackageBody) semanticObject); 
				return; 
			case AdbPackage.PACKAGE_BODY_STUB:
				sequence_PackageBodyStub(context, (PackageBodyStub) semanticObject); 
				return; 
			case AdbPackage.PACKAGE_DEFINITION:
				sequence_PackageDefinition(context, (PackageDefinition) semanticObject); 
				return; 
			case AdbPackage.PACKAGE_SPECIFICATION:
				sequence_PackageSpecification(context, (PackageSpecification) semanticObject); 
				return; 
			case AdbPackage.PARAMETER_AND_RESULT_PROFILE:
				sequence_ParameterAndResultProfile(context, (ParameterAndResultProfile) semanticObject); 
				return; 
			case AdbPackage.PARAMETER_ASSOCIATION:
				sequence_ParameterAssociation(context, (ParameterAssociation) semanticObject); 
				return; 
			case AdbPackage.PARAMETER_SPECIFICATION:
				sequence_ParameterSpecification(context, (ParameterSpecification) semanticObject); 
				return; 
			case AdbPackage.POSITIONAL_ARRAY_AGGREGATE:
				sequence_PositionalArrayAggregate(context, (PositionalArrayAggregate) semanticObject); 
				return; 
			case AdbPackage.PRAGMA:
				sequence_Pragma(context, (Pragma) semanticObject); 
				return; 
			case AdbPackage.PRAGMA_ARGUMENT_ASSOCIATION:
				sequence_PragmaArgumentAssociation(context, (PragmaArgumentAssociation) semanticObject); 
				return; 
			case AdbPackage.PRIMARY_NAME:
				sequence_PrimaryName(context, (PrimaryName) semanticObject); 
				return; 
			case AdbPackage.PRIVATE_EXTENSION_DECLARATION:
				sequence_PrivateExtensionDeclaration(context, (PrivateExtensionDeclaration) semanticObject); 
				return; 
			case AdbPackage.PRIVATE_TYPE_DECLARATION:
				sequence_PrivateTypeDeclaration(context, (PrivateTypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.PROCEDURE_OR_ENTRY_CALL_STATEMENT:
				sequence_ProcedureOrEntryCallStatement(context, (ProcedureOrEntryCallStatement) semanticObject); 
				return; 
			case AdbPackage.PROCEDURE_SPECIFICATION:
				sequence_ProcedureSpecification(context, (ProcedureSpecification) semanticObject); 
				return; 
			case AdbPackage.PROTECTED_BODY:
				sequence_ProtectedBody(context, (ProtectedBody) semanticObject); 
				return; 
			case AdbPackage.PROTECTED_BODY_STUB:
				sequence_ProtectedBodyStub(context, (ProtectedBodyStub) semanticObject); 
				return; 
			case AdbPackage.PROTECTED_DEFINITION:
				sequence_ProtectedDefinition(context, (ProtectedDefinition) semanticObject); 
				return; 
			case AdbPackage.PROTECTED_TYPE_DECLARATION:
				sequence_ProtectedTypeDeclaration(context, (ProtectedTypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.QUALIFIED_NAME:
				sequence_QualifiedName(context, (QualifiedName) semanticObject); 
				return; 
			case AdbPackage.RAISE_STATEMENT:
				sequence_RaiseStatement(context, (RaiseStatement) semanticObject); 
				return; 
			case AdbPackage.REAL_RANGE_SPECIFICATION:
				sequence_RealRangeSpecification(context, (RealRangeSpecification) semanticObject); 
				return; 
			case AdbPackage.RECORD_COMPONENT_ASSOCIATION_LIST:
				sequence_RecordComponentAssociationList(context, (RecordComponentAssociationList) semanticObject); 
				return; 
			case AdbPackage.RECORD_DEFINITION:
				sequence_RecordDefinition(context, (RecordDefinition) semanticObject); 
				return; 
			case AdbPackage.RECORD_EXTENSION_PART:
				sequence_RecordExtensionPart(context, (RecordExtensionPart) semanticObject); 
				return; 
			case AdbPackage.RECORD_TYPE_DEFINITION:
				sequence_RecordTypeDefinition(context, (RecordTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case AdbPackage.RENAMING:
				sequence_Renaming(context, (Renaming) semanticObject); 
				return; 
			case AdbPackage.REQUEUE_STATEMENT:
				sequence_RequeueStatement(context, (RequeueStatement) semanticObject); 
				return; 
			case AdbPackage.SELECT_ALTERNATIVE:
				sequence_SelectAlternative(context, (SelectAlternative) semanticObject); 
				return; 
			case AdbPackage.SELECTIVE_ACCEPT:
				sequence_SelectiveAccept(context, (SelectiveAccept) semanticObject); 
				return; 
			case AdbPackage.SEPARATE_SUBUNIT:
				sequence_SeparateSubunit(context, (SeparateSubunit) semanticObject); 
				return; 
			case AdbPackage.SEQUENCE_OF_STATEMENTS:
				if (rule == grammarAccess.getHandledSequenceOfStatementsRule()) {
					sequence_HandledSequenceOfStatements_SequenceOfStatements(context, (SequenceOfStatements) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceOfStatementsRule()
						|| rule == grammarAccess.getAbortablePartRule()) {
					sequence_SequenceOfStatements(context, (SequenceOfStatements) semanticObject); 
					return; 
				}
				else break;
			case AdbPackage.SIGNED_INTEGER_TYPE_DEFINITION:
				sequence_SignedIntegerTypeDefinition(context, (SignedIntegerTypeDefinition) semanticObject); 
				return; 
			case AdbPackage.SIMPLE_EXPRESSION:
				sequence_SimpleExpression(context, (SimpleExpression) semanticObject); 
				return; 
			case AdbPackage.SIMPLE_RETURN_STATEMENT:
				sequence_SimpleReturnStatement(context, (SimpleReturnStatement) semanticObject); 
				return; 
			case AdbPackage.SINGLE_PROTECTED_DECLARATION:
				sequence_SingleProtectedDeclaration(context, (SingleProtectedDeclaration) semanticObject); 
				return; 
			case AdbPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case AdbPackage.SUBPROGRAM_BODY:
				sequence_SubprogramBody(context, (SubprogramBody) semanticObject); 
				return; 
			case AdbPackage.SUBPROGRAM_DECLARATION:
				sequence_SubprogramDeclaration(context, (SubprogramDeclaration) semanticObject); 
				return; 
			case AdbPackage.SUBPROGRAM_DEFAULT:
				sequence_SubprogramDefault(context, (SubprogramDefault) semanticObject); 
				return; 
			case AdbPackage.SUBTYPE_DECLARATION:
				sequence_SubtypeDeclaration(context, (SubtypeDeclaration) semanticObject); 
				return; 
			case AdbPackage.SUBTYPE_INDICATION:
				sequence_SubtypeIndication(context, (SubtypeIndication) semanticObject); 
				return; 
			case AdbPackage.TASK_BODY:
				sequence_TaskBody(context, (TaskBody) semanticObject); 
				return; 
			case AdbPackage.TASK_BODY_STUB:
				sequence_TaskBodyStub(context, (TaskBodyStub) semanticObject); 
				return; 
			case AdbPackage.TASK_DECLARATION:
				sequence_TaskDeclaration(context, (TaskDeclaration) semanticObject); 
				return; 
			case AdbPackage.TASK_DEFINITION:
				sequence_TaskDefinition(context, (TaskDefinition) semanticObject); 
				return; 
			case AdbPackage.TASK_NAMES:
				sequence_TaskNames(context, (TaskNames) semanticObject); 
				return; 
			case AdbPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case AdbPackage.TIMED_ENTRY_CALL:
				sequence_TimedEntryCall(context, (TimedEntryCall) semanticObject); 
				return; 
			case AdbPackage.TRIGGERING_ALTERNATIVE:
				sequence_TriggeringAlternative(context, (TriggeringAlternative) semanticObject); 
				return; 
			case AdbPackage.UNCONSTRAINED_INDEXES:
				sequence_UnconstrainedIndexes(context, (UnconstrainedIndexes) semanticObject); 
				return; 
			case AdbPackage.UNINITIALIZED_COMPONENTS:
				sequence_UninitializedComponents(context, (UninitializedComponents) semanticObject); 
				return; 
			case AdbPackage.UNKNOWN_DISCRIMINANT_PART:
				sequence_UnknownDiscriminantPart(context, (UnknownDiscriminantPart) semanticObject); 
				return; 
			case AdbPackage.USE_PACKAGE_CLAUSE:
				sequence_UsePackageClause(context, (UsePackageClause) semanticObject); 
				return; 
			case AdbPackage.USE_TYPE_CLAUSE:
				sequence_UseTypeClause(context, (UseTypeClause) semanticObject); 
				return; 
			case AdbPackage.VARIANT:
				sequence_Variant(context, (Variant) semanticObject); 
				return; 
			case AdbPackage.VARIANT_PART:
				sequence_VariantPart(context, (VariantPart) semanticObject); 
				return; 
			case AdbPackage.WITH_CLAUSE:
				sequence_WithClause(context, (WithClause) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SelectAlternative returns AcceptAlternative
	 *     AcceptAlternative returns AcceptAlternative
	 *
	 * Constraint:
	 *     (acceptStatement=AcceptStatement sequenceOfStatements=SequenceOfStatements?)
	 */
	protected void sequence_AcceptAlternative(ISerializationContext context, AcceptAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AcceptStatement
	 *     CompoundStatement returns AcceptStatement
	 *     AcceptStatement returns AcceptStatement
	 *
	 * Constraint:
	 *     (
	 *         entryName=[EntryDeclaration|IDENTIFIER] 
	 *         entryIndex=EntryIndex? 
	 *         formalPart=FormalPart? 
	 *         (handledSequenceOfStatements=HandledSequenceOfStatements entryidentifier=IDENTIFIER?)?
	 *     )
	 */
	protected void sequence_AcceptStatement(ISerializationContext context, AcceptStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AccessSpecification returns AccessToDataDefinition
	 *     AccessToDataDefinition returns AccessToDataDefinition
	 *
	 * Constraint:
	 *     (generalAccessModifier=GeneralAccessModifier? subtypeIndication=SubtypeIndication)
	 */
	protected void sequence_AccessToDataDefinition(ISerializationContext context, AccessToDataDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotNullAccessDefinition returns AccessToDataInstance
	 *     AccessToDataInstance returns AccessToDataInstance
	 *
	 * Constraint:
	 *     (constant=CONSTANT_? name=Name)
	 */
	protected void sequence_AccessToDataInstance(ISerializationContext context, AccessToDataInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AccessSpecification returns AccessToSubprogramDefinition
	 *     AccessToSubprogramDefinition returns AccessToSubprogramDefinition
	 *     NotNullAccessDefinition returns AccessToSubprogramDefinition
	 *
	 * Constraint:
	 *     (protected?=PROTECTED_? (formalPart=FormalPart | parameterAndResultProfile=ParameterAndResultProfile)?)
	 */
	protected void sequence_AccessToSubprogramDefinition(ISerializationContext context, AccessToSubprogramDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns AccessTypeDefinition
	 *     TypeDefinition returns AccessTypeDefinition
	 *     AccessTypeDefinition returns AccessTypeDefinition
	 *
	 * Constraint:
	 *     (optNullExclusion=OptNullExclusion accessDefinition=AccessSpecification)
	 */
	protected void sequence_AccessTypeDefinition(ISerializationContext context, AccessTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAccessTypeDefinition_OptNullExclusion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAccessTypeDefinition_OptNullExclusion()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAccessTypeDefinition_AccessDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAccessTypeDefinition_AccessDefinition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessTypeDefinitionAccess().getOptNullExclusionOptNullExclusionParserRuleCall_0_0(), semanticObject.getOptNullExclusion());
		feeder.accept(grammarAccess.getAccessTypeDefinitionAccess().getAccessDefinitionAccessSpecificationParserRuleCall_1_0(), semanticObject.getAccessDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns Allocator
	 *     Allocator returns Allocator
	 *
	 * Constraint:
	 *     (typeName=Name qualifier=Qualifier?)
	 */
	protected void sequence_Allocator(ISerializationContext context, Allocator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnSubtypeIndication returns AnonymousAccessDefinition
	 *     AnonymousAccessDefinition returns AnonymousAccessDefinition
	 *
	 * Constraint:
	 *     (optNullExclusion=OptNullExclusion accessDef=NotNullAccessDefinition)
	 */
	protected void sequence_AnonymousAccessDefinition(ISerializationContext context, AnonymousAccessDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAnonymousAccessDefinition_OptNullExclusion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAnonymousAccessDefinition_OptNullExclusion()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAnonymousAccessDefinition_AccessDef()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAnonymousAccessDefinition_AccessDef()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousAccessDefinitionAccess().getOptNullExclusionOptNullExclusionParserRuleCall_0_0(), semanticObject.getOptNullExclusion());
		feeder.accept(grammarAccess.getAnonymousAccessDefinitionAccess().getAccessDefNotNullAccessDefinitionParserRuleCall_1_0(), semanticObject.getAccessDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayComponentAssociation returns ArrayComponentAssociation
	 *
	 * Constraint:
	 *     (discreteChoiceList=DiscreteChoiceList (expression=Expression | box?=BOIT))
	 */
	protected void sequence_ArrayComponentAssociation(ISerializationContext context, ArrayComponentAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns ArrayTypeDefinition
	 *     TypeDefinition returns ArrayTypeDefinition
	 *     ArrayTypeDefinition returns ArrayTypeDefinition
	 *
	 * Constraint:
	 *     (arrayIndexes=ArrayIndexes componentDefinition=ComponentDefinition)
	 */
	protected void sequence_ArrayTypeDefinition(ISerializationContext context, ArrayTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getArrayTypeDefinition_ArrayIndexes()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getArrayTypeDefinition_ArrayIndexes()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getArrayTypeDefinition_ComponentDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getArrayTypeDefinition_ComponentDefinition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeDefinitionAccess().getArrayIndexesArrayIndexesParserRuleCall_2_0(), semanticObject.getArrayIndexes());
		feeder.accept(grammarAccess.getArrayTypeDefinitionAccess().getComponentDefinitionComponentDefinitionParserRuleCall_5_0(), semanticObject.getComponentDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns AspectClause
	 *     TaskItem returns AspectClause
	 *     ProtectedElementDeclaration returns AspectClause
	 *     ProtectedOperationDeclaration returns AspectClause
	 *     DeclarativeItem returns AspectClause
	 *     ProtectedOperationItem returns AspectClause
	 *     ComponentItem returns AspectClause
	 *     AspectClause returns AspectClause
	 *
	 * Constraint:
	 *     (name=PATHNAME (expression=Expression | (mod=ModClause? componentClause+=ComponentClause*) | expression=Expression)?)
	 */
	protected void sequence_AspectClause(ISerializationContext context, AspectClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentStatement
	 *     SimpleStatement returns AssignmentStatement
	 *     AssignmentStatement returns AssignmentStatement
	 *
	 * Constraint:
	 *     (variableName=Name initialValue=Expression)
	 */
	protected void sequence_AssignmentStatement(ISerializationContext context, AssignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAssignmentStatement_VariableName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAssignmentStatement_VariableName()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAssignmentStatement_InitialValue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAssignmentStatement_InitialValue()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getVariableNameNameParserRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getInitialValueExpressionParserRuleCall_2_0(), semanticObject.getInitialValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AsynchronousSelect
	 *     CompoundStatement returns AsynchronousSelect
	 *     SelectStatement returns AsynchronousSelect
	 *     AsynchronousSelect returns AsynchronousSelect
	 *
	 * Constraint:
	 *     (triggeringAlternative=TriggeringAlternative abortablePart=AbortablePart)
	 */
	protected void sequence_AsynchronousSelect(ISerializationContext context, AsynchronousSelect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAsynchronousSelect_TriggeringAlternative()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAsynchronousSelect_TriggeringAlternative()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getAsynchronousSelect_AbortablePart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getAsynchronousSelect_AbortablePart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsynchronousSelectAccess().getTriggeringAlternativeTriggeringAlternativeParserRuleCall_1_0(), semanticObject.getTriggeringAlternative());
		feeder.accept(grammarAccess.getAsynchronousSelectAccess().getAbortablePartAbortablePartParserRuleCall_5_0(), semanticObject.getAbortablePart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeDesignator returns AttributeDesignator
	 *
	 * Constraint:
	 *     staticExpression=ParenthesizedExpression?
	 */
	protected void sequence_AttributeDesignator(ISerializationContext context, AttributeDesignator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeBlock returns BlockStatement
	 *     Statement returns BlockStatement
	 *     CompoundStatement returns BlockStatement
	 *     BlockStatement returns BlockStatement
	 *
	 * Constraint:
	 *     (blockStatementIdentifier=IDENTIFIER? declarativeItems+=DeclarativeItem* handledSequenceOfStatements=HandledSequenceOfStatements)
	 */
	protected void sequence_BlockStatement(ISerializationContext context, BlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseStatementAlternative returns CaseStatementAlternative
	 *
	 * Constraint:
	 *     (discreteChoiceList=DiscreteChoiceList sequenceOfStatements=SequenceOfStatements)
	 */
	protected void sequence_CaseStatementAlternative(ISerializationContext context, CaseStatementAlternative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getCaseStatementAlternative_DiscreteChoiceList()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getCaseStatementAlternative_DiscreteChoiceList()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getCaseStatementAlternative_SequenceOfStatements()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getCaseStatementAlternative_SequenceOfStatements()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseStatementAlternativeAccess().getDiscreteChoiceListDiscreteChoiceListParserRuleCall_1_0(), semanticObject.getDiscreteChoiceList());
		feeder.accept(grammarAccess.getCaseStatementAlternativeAccess().getSequenceOfStatementsSequenceOfStatementsParserRuleCall_3_0(), semanticObject.getSequenceOfStatements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CaseStatement
	 *     CompoundStatement returns CaseStatement
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (caseValue=Expression caseStatementAlternatives+=CaseStatementAlternative+)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompilationUnit returns CompilationUnit
	 *
	 * Constraint:
	 *     (contextClause=ContextClause unit=Unit pragmas+=Pragma*)
	 */
	protected void sequence_CompilationUnit(ISerializationContext context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Compilation returns Compilation
	 *
	 * Constraint:
	 *     compilationUnits+=CompilationUnit+
	 */
	protected void sequence_Compilation(ISerializationContext context, Compilation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentChoiceList returns ComponentChoiceList
	 *
	 * Constraint:
	 *     ((componentSelectorName+=SelectorName componentSelectorName+=SelectorName*) | others?=OTHERS_)
	 */
	protected void sequence_ComponentChoiceList(ISerializationContext context, ComponentChoiceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentClause returns ComponentClause
	 *
	 * Constraint:
	 *     (localName=PATHIDENTIFIER position=Expression firstBit=SimpleExpression lastBit=SimpleExpression)
	 */
	protected void sequence_ComponentClause(ISerializationContext context, ComponentClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getComponentClause_LocalName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getComponentClause_LocalName()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getComponentClause_Position()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getComponentClause_Position()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getComponentClause_FirstBit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getComponentClause_FirstBit()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getComponentClause_LastBit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getComponentClause_LastBit()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentClauseAccess().getLocalNamePATHIDENTIFIERParserRuleCall_0_0(), semanticObject.getLocalName());
		feeder.accept(grammarAccess.getComponentClauseAccess().getPositionExpressionParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.accept(grammarAccess.getComponentClauseAccess().getFirstBitSimpleExpressionParserRuleCall_4_0(), semanticObject.getFirstBit());
		feeder.accept(grammarAccess.getComponentClauseAccess().getLastBitSimpleExpressionParserRuleCall_6_0(), semanticObject.getLastBit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProtectedElementDeclaration returns ComponentDeclaration
	 *     ComponentItem returns ComponentDeclaration
	 *     ComponentDeclaration returns ComponentDeclaration
	 *
	 * Constraint:
	 *     (definingIdentifiers=DefiningIdentifierList componentDefinition=ComponentDefinition defaultExpression=Expression?)
	 */
	protected void sequence_ComponentDeclaration(ISerializationContext context, ComponentDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDefinition returns ComponentDefinition
	 *
	 * Constraint:
	 *     (aliased?=ALIASED_? (subtypeIndication=SubtypeIndication | anonymousAccessDefinition=AnonymousAccessDefinition))
	 */
	protected void sequence_ComponentDefinition(ISerializationContext context, ComponentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentList returns ComponentList
	 *
	 * Constraint:
	 *     (componentItems+=ComponentItem* optVariantPart=OptVariantPart)
	 */
	protected void sequence_ComponentList(ISerializationContext context, ComponentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionalEntryCall
	 *     CompoundStatement returns ConditionalEntryCall
	 *     SelectStatement returns ConditionalEntryCall
	 *     ConditionalEntryCall returns ConditionalEntryCall
	 *
	 * Constraint:
	 *     (entryCallAlternative=EntryCallAlternative elseSequenceOfStatements=SequenceOfStatements)
	 */
	protected void sequence_ConditionalEntryCall(ISerializationContext context, ConditionalEntryCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getConditionalEntryCall_EntryCallAlternative()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getConditionalEntryCall_EntryCallAlternative()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getConditionalEntryCall_ElseSequenceOfStatements()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getConditionalEntryCall_ElseSequenceOfStatements()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalEntryCallAccess().getEntryCallAlternativeEntryCallAlternativeParserRuleCall_1_0(), semanticObject.getEntryCallAlternative());
		feeder.accept(grammarAccess.getConditionalEntryCallAccess().getElseSequenceOfStatementsSequenceOfStatementsParserRuleCall_3_0(), semanticObject.getElseSequenceOfStatements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayIndexes returns ConstrainedIndexes
	 *     ConstrainedIndexes returns ConstrainedIndexes
	 *
	 * Constraint:
	 *     (constrainedIndex+=DiscreteSubtypeDefinition constrainedIndex+=DiscreteSubtypeDefinition*)
	 */
	protected void sequence_ConstrainedIndexes(ISerializationContext context, ConstrainedIndexes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextClause returns ContextClause
	 *
	 * Constraint:
	 *     contextItems+=ContextItem*
	 */
	protected void sequence_ContextClause(ISerializationContext context, ContextClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns DataInstanceDeclaration
	 *     BasicDeclaration returns DataInstanceDeclaration
	 *     DeclarativeItem returns DataInstanceDeclaration
	 *     ObjectDeclaration returns DataInstanceDeclaration
	 *     DataInstanceDeclaration returns DataInstanceDeclaration
	 *
	 * Constraint:
	 *     (
	 *         definingIdentifierList=DefiningIdentifierList 
	 *         aliased?=ALIASED_? 
	 *         constant?=CONSTANT_? 
	 *         (
	 *             (subtypeIndication=SubtypeIndication (expression=Expression | objectName=Name)?) | 
	 *             (anonymousAccessDefinition=AnonymousAccessDefinition (expression=Expression | objectName=Name)?) | 
	 *             (arrayTypeDefinition=ArrayTypeDefinition expression=Expression?)
	 *         )
	 *     )
	 */
	protected void sequence_DataInstanceDeclaration(ISerializationContext context, DataInstanceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefiningIdentifierList returns DefiningIdentifierList
	 *
	 * Constraint:
	 *     (name+=IDENTIFIER name+=IDENTIFIER*)
	 */
	protected void sequence_DefiningIdentifierList(ISerializationContext context, DefiningIdentifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectAlternative returns DelayAlternative
	 *     DelayAlternative returns DelayAlternative
	 *
	 * Constraint:
	 *     (delayStatement=DelayStatement sequenceOfStatements=SequenceOfStatements?)
	 */
	protected void sequence_DelayAlternative(ISerializationContext context, DelayAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DelayStatement
	 *     SimpleStatement returns DelayStatement
	 *     DelayStatement returns DelayStatement
	 *     TriggeringStatement returns DelayStatement
	 *
	 * Constraint:
	 *     (until=UNTIL_? delay=Expression)
	 */
	protected void sequence_DelayStatement(ISerializationContext context, DelayStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScalarConstraint returns DeltaConstraint
	 *     DeltaConstraint returns DeltaConstraint
	 *
	 * Constraint:
	 *     (delta=SimpleExpression rangeConstraint=RangeConstraint?)
	 */
	protected void sequence_DeltaConstraint(ISerializationContext context, DeltaConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns DerivedTypeDefinition
	 *     DerivedTypeDefinition returns DerivedTypeDefinition
	 *
	 * Constraint:
	 *     (
	 *         abstract=ABSTRACT_? 
	 *         limited=LIMITED_? 
	 *         subtypeIndication=SubtypeIndication 
	 *         (interfaceList=InterfaceList? recordExtentionPart=RecordExtensionPart)?
	 *     )
	 */
	protected void sequence_DerivedTypeDefinition(ISerializationContext context, DerivedTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScalarConstraint returns DigitsConstraint
	 *     DigitsConstraint returns DigitsConstraint
	 *
	 * Constraint:
	 *     (digits=SimpleExpression rangeConstraint=RangeConstraint?)
	 */
	protected void sequence_DigitsConstraint(ISerializationContext context, DigitsConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscreteChoiceList returns DiscreteChoiceList
	 *
	 * Constraint:
	 *     (discreteChoiceList+=DiscreteChoice discreteChoiceList+=DiscreteChoice*)
	 */
	protected void sequence_DiscreteChoiceList(ISerializationContext context, DiscreteChoiceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscreteChoice returns DiscreteChoice
	 *
	 * Constraint:
	 *     {DiscreteChoice}
	 */
	protected void sequence_DiscreteChoice(ISerializationContext context, DiscreteChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscriminantAssociation returns DiscriminantAssociation
	 *
	 * Constraint:
	 *     (discriminantSelectors=DiscriminantSelectors? actualParameter=Expression)
	 */
	protected void sequence_DiscriminantAssociation(ISerializationContext context, DiscriminantAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeConstraint returns DiscriminantConstraint
	 *     DiscriminantConstraint returns DiscriminantConstraint
	 *
	 * Constraint:
	 *     (discriminantAssociation+=DiscriminantAssociation discriminantAssociation+=DiscriminantAssociation*)
	 */
	protected void sequence_DiscriminantConstraint(ISerializationContext context, DiscriminantConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscriminantSelectors returns DiscriminantSelectors
	 *
	 * Constraint:
	 *     (discriminantSelectorName+=SelectorName discriminantSelectorName+=SelectorName*)
	 */
	protected void sequence_DiscriminantSelectors(ISerializationContext context, DiscriminantSelectors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscriminantSpecification returns DiscriminantSpecification
	 *
	 * Constraint:
	 *     (
	 *         definingIdentifiers=DefiningIdentifierList 
	 *         optNullExclusion=OptNullExclusion 
	 *         (accessDefinition=NotNullAccessDefinition | subtypeMark=Name) 
	 *         defaultValue=Expression?
	 *     )
	 */
	protected void sequence_DiscriminantSpecification(ISerializationContext context, DiscriminantSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscreteSubtypeDefinition returns EntityRange
	 *     Interval returns EntityRange
	 *     ScalarConstraint returns EntityRange
	 *     RangeConstraint returns EntityRange
	 *     DiscreteRange returns EntityRange
	 *     DiscreteChoice returns EntityRange
	 *     ParameterEffectiveValue returns EntityRange
	 *     Range returns EntityRange
	 *     EntityRange returns EntityRange
	 *
	 * Constraint:
	 *     (name=Name index=Expression?)
	 */
	protected void sequence_EntityRange(ISerializationContext context, EntityRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryBarrier returns EntryBarrier
	 *
	 * Constraint:
	 *     condition=Expression
	 */
	protected void sequence_EntryBarrier(ISerializationContext context, EntryBarrier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getEntryBarrier_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getEntryBarrier_Condition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryBarrierAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryBodyFormalPart returns EntryBodyFormalPart
	 *
	 * Constraint:
	 *     (entryIndexSpecification=EntryIndexSpecification? formalPart=FormalPart?)
	 */
	protected void sequence_EntryBodyFormalPart(ISerializationContext context, EntryBodyFormalPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeBlock returns EntryBody
	 *     ProtectedOperationItem returns EntryBody
	 *     EntryBody returns EntryBody
	 *
	 * Constraint:
	 *     (
	 *         name=[EntryDeclaration|IDENTIFIER] 
	 *         entryBodyFormalPart=EntryBodyFormalPart 
	 *         entryBarrier=EntryBarrier 
	 *         declarativeItems+=DeclarativeItem* 
	 *         handledSequenceOfStatements=HandledSequenceOfStatements 
	 *         endid=IDENTIFIER?
	 *     )
	 */
	protected void sequence_EntryBody(ISerializationContext context, EntryBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryCallAlternative returns EntryCallAlternative
	 *
	 * Constraint:
	 *     (call=ProcedureOrEntryCallStatement sequenceOfStatements=SequenceOfStatements?)
	 */
	protected void sequence_EntryCallAlternative(ISerializationContext context, EntryCallAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TaskItem returns EntryDeclaration
	 *     EntryDeclaration returns EntryDeclaration
	 *     ProtectedElementDeclaration returns EntryDeclaration
	 *     ProtectedOperationDeclaration returns EntryDeclaration
	 *
	 * Constraint:
	 *     (overriding=OverridingIndicator? name=IDENTIFIER discreteSubtypeDefinition=DiscreteSubtypeDefinition? formalPart=FormalPart?)
	 */
	protected void sequence_EntryDeclaration(ISerializationContext context, EntryDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryIndexSpecification returns EntryIndexSpecification
	 *
	 * Constraint:
	 *     (name=IDENTIFIER discreteSubtypeDefinition=DiscreteSubtypeDefinition)
	 */
	protected void sequence_EntryIndexSpecification(ISerializationContext context, EntryIndexSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getEntryIndexSpecification_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getEntryIndexSpecification_Name()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getEntryIndexSpecification_DiscreteSubtypeDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getEntryIndexSpecification_DiscreteSubtypeDefinition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryIndexSpecificationAccess().getNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEntryIndexSpecificationAccess().getDiscreteSubtypeDefinitionDiscreteSubtypeDefinitionParserRuleCall_3_0(), semanticObject.getDiscreteSubtypeDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns EnumerationTypeDefinition
	 *     EnumerationTypeDefinition returns EnumerationTypeDefinition
	 *
	 * Constraint:
	 *     (enumerationliteralspecifications+=EnumerationLiteralSpecification enumerationliteralspecifications+=EnumerationLiteralSpecification*)
	 */
	protected void sequence_EnumerationTypeDefinition(ISerializationContext context, EnumerationTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionChoice returns ExceptionChoice
	 *
	 * Constraint:
	 *     (name=Name | others?=OTHERS_)
	 */
	protected void sequence_ExceptionChoice(ISerializationContext context, ExceptionChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns ExceptionDeclaration
	 *     BasicDeclaration returns ExceptionDeclaration
	 *     DeclarativeItem returns ExceptionDeclaration
	 *     ExceptionDeclaration returns ExceptionDeclaration
	 *
	 * Constraint:
	 *     (idList=DefiningIdentifierList renamedName=Name?)
	 */
	protected void sequence_ExceptionDeclaration(ISerializationContext context, ExceptionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionHandler returns ExceptionHandler
	 *
	 * Constraint:
	 *     (name=IDENTIFIER? exceptionChoice+=ExceptionChoice exceptionChoice+=ExceptionChoice* sequenceOfStatements=SequenceOfStatements)
	 */
	protected void sequence_ExceptionHandler(ISerializationContext context, ExceptionHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExitStatement
	 *     SimpleStatement returns ExitStatement
	 *     ExitStatement returns ExitStatement
	 *
	 * Constraint:
	 *     (name=[LoopStatement|IDENTIFIER]? condition=Expression?)
	 */
	protected void sequence_ExitStatement(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscreteSubtypeDefinition returns ExplicitRange
	 *     Interval returns ExplicitRange
	 *     ScalarConstraint returns ExplicitRange
	 *     RangeConstraint returns ExplicitRange
	 *     DiscreteRange returns ExplicitRange
	 *     DiscreteChoice returns ExplicitRange
	 *     ParameterEffectiveValue returns ExplicitRange
	 *     Range returns ExplicitRange
	 *     ExplicitRange returns ExplicitRange
	 *
	 * Constraint:
	 *     (first=SimpleExpression last=SimpleExpression)
	 */
	protected void sequence_ExplicitRange(ISerializationContext context, ExplicitRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getExplicitRange_First()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getExplicitRange_First()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getExplicitRange_Last()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getExplicitRange_Last()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExplicitRangeAccess().getFirstSimpleExpressionParserRuleCall_0_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getExplicitRangeAccess().getLastSimpleExpressionParserRuleCall_2_0(), semanticObject.getLast());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryIndex returns Expression
	 *     ExplicitGenericActualParameter returns Expression
	 *     Expression returns Expression
	 *     DiscreteChoice returns Expression
	 *     AncestorPart returns Expression
	 *     ParameterEffectiveValue returns Expression
	 *
	 * Constraint:
	 *     (relations+=Relation (booleanOperator+=BooleanOperator relations+=Relation)*)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExtendedReturnStatement
	 *     CompoundStatement returns ExtendedReturnStatement
	 *     ExtendedReturnStatement returns ExtendedReturnStatement
	 *
	 * Constraint:
	 *     (identifier=IDENTIFIER returnSubtype=ReturnSubtypeIndication expression=Expression? handledSequenceOfStatements=HandledSequenceOfStatements?)
	 */
	protected void sequence_ExtendedReturnStatement(ISerializationContext context, ExtendedReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns ExtensionAggregate
	 *     ParenthesizedExpression returns ExtensionAggregate
	 *     Qualifier returns ExtensionAggregate
	 *     Aggregate returns ExtensionAggregate
	 *     ExtensionAggregate returns ExtensionAggregate
	 *
	 * Constraint:
	 *     (ancestorPart=AncestorPart recordComponentAssociationList=RecordComponentAssociationList)
	 */
	protected void sequence_ExtensionAggregate(ISerializationContext context, ExtensionAggregate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getExtensionAggregate_AncestorPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getExtensionAggregate_AncestorPart()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getExtensionAggregate_RecordComponentAssociationList()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getExtensionAggregate_RecordComponentAssociationList()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtensionAggregateAccess().getAncestorPartAncestorPartParserRuleCall_0_0(), semanticObject.getAncestorPart());
		feeder.accept(grammarAccess.getExtensionAggregateAccess().getRecordComponentAssociationListRecordComponentAssociationListParserRuleCall_2_0(), semanticObject.getRecordComponentAssociationList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     ((primary=Primary exponent=Primary?) | (abs?=ABS_ primary=Primary) | (not?=NOT_ primary=Primary))
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns FixedPointDefinition
	 *     RealTypeDefinition returns FixedPointDefinition
	 *     FixedPointDefinition returns FixedPointDefinition
	 *
	 * Constraint:
	 *     (delta=Expression (realRangeSpecification=RealRangeSpecification | (digits=Expression realRangeSpecification=RealRangeSpecification?)))
	 */
	protected void sequence_FixedPointDefinition(ISerializationContext context, FixedPointDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns FloatingPointDefinition
	 *     RealTypeDefinition returns FloatingPointDefinition
	 *     FloatingPointDefinition returns FloatingPointDefinition
	 *
	 * Constraint:
	 *     (digits=Expression realRangeSpecification=RealRangeSpecification?)
	 */
	protected void sequence_FloatingPointDefinition(ISerializationContext context, FloatingPointDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns FormalDerivedTypeDefinition
	 *     FormalDerivedTypeDefinition returns FormalDerivedTypeDefinition
	 *
	 * Constraint:
	 *     (absract=ABSTRACT_? (limited?=LIMITED_ | synchronized?=SYNCHRONIZED_)? subtypeMark=Name interfaceList=InterfaceList?)
	 */
	protected void sequence_FormalDerivedTypeDefinition(ISerializationContext context, FormalDerivedTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericItem returns FormalObjectDeclaration
	 *     GenericFormalParameterDeclaration returns FormalObjectDeclaration
	 *     FormalObjectDeclaration returns FormalObjectDeclaration
	 *
	 * Constraint:
	 *     (
	 *         idList=DefiningIdentifierList 
	 *         mode=Mode 
	 *         ((optNullExclusion=OptNullExclusion subtypeMark=Name) | anonymousAccessDefinition=AnonymousAccessDefinition) 
	 *         defaultExpression=Expression?
	 *     )
	 */
	protected void sequence_FormalObjectDeclaration(ISerializationContext context, FormalObjectDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalPackageActualPart returns FormalPackageActualPart
	 *
	 * Constraint:
	 *     (
	 *         box?=BOIT | 
	 *         genericActualPart=GenericActualPart | 
	 *         (formalPackageAssociation+=FormalPackageAssociation formalPackageAssociation+=FormalPackageAssociation*)
	 *     )?
	 */
	protected void sequence_FormalPackageActualPart(ISerializationContext context, FormalPackageActualPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalPackageAssociation returns FormalPackageAssociation
	 *
	 * Constraint:
	 *     (genericAssociation=GenericAssociation | genericFormalParameterSelectorName=SelectorName)
	 */
	protected void sequence_FormalPackageAssociation(ISerializationContext context, FormalPackageAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericItem returns FormalPackageDeclaration
	 *     GenericFormalParameterDeclaration returns FormalPackageDeclaration
	 *     FormalPackageDeclaration returns FormalPackageDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER genericPackageName=PATHIDENTIFIER formalPackageActualPart=FormalPackageActualPart)
	 */
	protected void sequence_FormalPackageDeclaration(ISerializationContext context, FormalPackageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_Name()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_GenericPackageName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_GenericPackageName()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_FormalPackageActualPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getFormalPackageDeclaration_FormalPackageActualPart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalPackageDeclarationAccess().getNameIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFormalPackageDeclarationAccess().getGenericPackageNamePATHIDENTIFIERParserRuleCall_5_0(), semanticObject.getGenericPackageName());
		feeder.accept(grammarAccess.getFormalPackageDeclarationAccess().getFormalPackageActualPartFormalPackageActualPartParserRuleCall_6_0(), semanticObject.getFormalPackageActualPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FormalPart returns FormalPart
	 *
	 * Constraint:
	 *     (parameterSpecifications+=ParameterSpecification parameterSpecifications+=ParameterSpecification*)
	 */
	protected void sequence_FormalPart(ISerializationContext context, FormalPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns FormalPrivateTypeDefinition
	 *     FormalPrivateTypeDefinition returns FormalPrivateTypeDefinition
	 *
	 * Constraint:
	 *     ((abstract?=ABSTRACT_? tagged?=TAGGED_)? limited?=LIMITED_?)
	 */
	protected void sequence_FormalPrivateTypeDefinition(ISerializationContext context, FormalPrivateTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericItem returns FormalSubprogramDeclaration
	 *     GenericFormalParameterDeclaration returns FormalSubprogramDeclaration
	 *     FormalSubprogramDeclaration returns FormalSubprogramDeclaration
	 *
	 * Constraint:
	 *     (subprogramSpecification=SubprogramSpecification (abstract=ABSTRACT_? subprogramDefault=SubprogramDefault)?)
	 */
	protected void sequence_FormalSubprogramDeclaration(ISerializationContext context, FormalSubprogramDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericItem returns FormalTypeDeclaration
	 *     GenericFormalParameterDeclaration returns FormalTypeDeclaration
	 *     FormalTypeDeclaration returns FormalTypeDeclaration
	 *
	 * Constraint:
	 *     (identifier=IDENTIFIER discriminantPart=DiscriminantPart? formalTypeDefinition=FormalTypeDefinition)
	 */
	protected void sequence_FormalTypeDeclaration(ISerializationContext context, FormalTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns FormalTypeDefinition
	 *
	 * Constraint:
	 *     {FormalTypeDefinition}
	 */
	protected void sequence_FormalTypeDefinition(ISerializationContext context, FormalTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns FullDataTypeDeclaration
	 *     BasicDeclaration returns FullDataTypeDeclaration
	 *     TypeDeclaration returns FullDataTypeDeclaration
	 *     NewTypeDeclaration returns FullDataTypeDeclaration
	 *     FullTypeDeclaration returns FullDataTypeDeclaration
	 *     FullDataTypeDeclaration returns FullDataTypeDeclaration
	 *     DeclarativeItem returns FullDataTypeDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER knownDiscriminantPart=KnownDiscriminantPart? typeDefinition=TypeDefinition)
	 */
	protected void sequence_FullDataTypeDeclaration(ISerializationContext context, FullDataTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns FunctionSpecification
	 *     SubprogramSpecification returns FunctionSpecification
	 *     FunctionSpecification returns FunctionSpecification
	 *     DeclarativeItem returns FunctionSpecification
	 *     Body returns FunctionSpecification
	 *     LibrarySpecification returns FunctionSpecification
	 *     BodyStub returns FunctionSpecification
	 *
	 * Constraint:
	 *     (overridingIndicator=OverridingIndicator? name=DIRECT_NAME parameterAndResultProfile=ParameterAndResultProfile)
	 */
	protected void sequence_FunctionSpecification(ISerializationContext context, FunctionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericActualPart returns GenericActualPart
	 *
	 * Constraint:
	 *     (genericAssociation+=GenericAssociation genericAssociation+=GenericAssociation*)
	 */
	protected void sequence_GenericActualPart(ISerializationContext context, GenericActualPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericAssociation returns GenericAssociation
	 *
	 * Constraint:
	 *     (selectorName=SelectorName? expplicitGenericActualParam=ExplicitGenericActualParameter)
	 */
	protected void sequence_GenericAssociation(ISerializationContext context, GenericAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns GenericDeclaration
	 *     GenericDeclaration returns GenericDeclaration
	 *     BasicDeclarativeItem returns GenericDeclaration
	 *     BasicDeclaration returns GenericDeclaration
	 *     DeclarativeItem returns GenericDeclaration
	 *
	 * Constraint:
	 *     (genericItems=GenericItems librarySpecification=LibrarySpecification)
	 */
	protected void sequence_GenericDeclaration(ISerializationContext context, GenericDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getGenericDeclaration_GenericItems()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getGenericDeclaration_GenericItems()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getGenericDeclaration_LibrarySpecification()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getGenericDeclaration_LibrarySpecification()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGenericDeclarationAccess().getGenericItemsGenericItemsParserRuleCall_1_0(), semanticObject.getGenericItems());
		feeder.accept(grammarAccess.getGenericDeclarationAccess().getLibrarySpecificationLibrarySpecificationParserRuleCall_2_0(), semanticObject.getLibrarySpecification());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns GenericInstantiation
	 *     GenericInstantiation returns GenericInstantiation
	 *     BasicDeclarativeItem returns GenericInstantiation
	 *     BasicDeclaration returns GenericInstantiation
	 *     DeclarativeItem returns GenericInstantiation
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (name=PATHIDENTIFIER genericName=PATHIDENTIFIER) | 
	 *             (overriding=OverridingIndicator? name=PATHIDENTIFIER genericName=PATHIDENTIFIER) | 
	 *             (overriding=OverridingIndicator? name=PATHNAME genericName=PATHNAME)
	 *         ) 
	 *         genericActualPart=GenericActualPart?
	 *     )
	 */
	protected void sequence_GenericInstantiation(ISerializationContext context, GenericInstantiation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericItems returns GenericItems
	 *
	 * Constraint:
	 *     genericItems+=GenericItem*
	 */
	protected void sequence_GenericItems(ISerializationContext context, GenericItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GotoStatement
	 *     SimpleStatement returns GotoStatement
	 *     GotoStatement returns GotoStatement
	 *
	 * Constraint:
	 *     labelId=IDENTIFIER
	 */
	protected void sequence_GotoStatement(ISerializationContext context, GotoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getGotoStatement_LabelId()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getGotoStatement_LabelId()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoStatementAccess().getLabelIdIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getLabelId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Guard returns Guard
	 *
	 * Constraint:
	 *     condition=Expression
	 */
	protected void sequence_Guard(ISerializationContext context, Guard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getGuard_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getGuard_Condition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GuardedAlternative returns GuardedAlternative
	 *
	 * Constraint:
	 *     (guard=Guard? alternative=SelectAlternative)
	 */
	protected void sequence_GuardedAlternative(ISerializationContext context, GuardedAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HandledSequenceOfStatements returns SequenceOfStatements
	 *
	 * Constraint:
	 *     (statements+=LabelisableStatement+ exceptionHandler+=ExceptionHandler*)
	 */
	protected void sequence_HandledSequenceOfStatements_SequenceOfStatements(ISerializationContext context, SequenceOfStatements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     CompoundStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (
	 *         ifCondition=Expression 
	 *         thenStatements=SequenceOfStatements 
	 *         (elsifConditions+=Expression elsifStatements+=SequenceOfStatements)* 
	 *         elseStatements=SequenceOfStatements?
	 *     )
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns IncompleteTypeDeclaration
	 *     BasicDeclaration returns IncompleteTypeDeclaration
	 *     TypeDeclaration returns IncompleteTypeDeclaration
	 *     NewTypeDeclaration returns IncompleteTypeDeclaration
	 *     IncompleteTypeDeclaration returns IncompleteTypeDeclaration
	 *     DeclarativeItem returns IncompleteTypeDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER discriminantPart=DiscriminantPart? tagged?=IS_?)
	 */
	protected void sequence_IncompleteTypeDeclaration(ISerializationContext context, IncompleteTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeConstraint returns IndexConstraint
	 *     IndexConstraint returns IndexConstraint
	 *
	 * Constraint:
	 *     (discreteRange+=DiscreteRange discreteRange+=DiscreteRange*)
	 */
	protected void sequence_IndexConstraint(ISerializationContext context, IndexConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecordComponentAssociation returns InitializedComponents
	 *     InitializedComponents returns InitializedComponents
	 *
	 * Constraint:
	 *     (componentChoiceList+=ComponentChoiceList? value=Expression)
	 */
	protected void sequence_InitializedComponents(ISerializationContext context, InitializedComponents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceList returns InterfaceList
	 *
	 * Constraint:
	 *     (interfaceSubtypeMark+=Name interfaceSubtypeMark+=Name*)
	 */
	protected void sequence_InterfaceList(ISerializationContext context, InterfaceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalTypeDefinition returns InterfaceTypeDefinition
	 *     TypeDefinition returns InterfaceTypeDefinition
	 *     InterfaceTypeDefinition returns InterfaceTypeDefinition
	 *
	 * Constraint:
	 *     ((limited?=LIMITED_ | task?=TASK_ | protected?=PROTECTED_ | synchro?=SYNCHRONIZED_)? interfaceList=InterfaceList?)
	 */
	protected void sequence_InterfaceTypeDefinition(ISerializationContext context, InterfaceTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IterationScheme returns IterationScheme
	 *
	 * Constraint:
	 *     (condition=Expression | iterationSpecification=LoopParameterSpecification)
	 */
	protected void sequence_IterationScheme(ISerializationContext context, IterationScheme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscriminantPart returns KnownDiscriminantPart
	 *     KnownDiscriminantPart returns KnownDiscriminantPart
	 *
	 * Constraint:
	 *     (discriminantsSpecification+=DiscriminantSpecification discriminantsSpecification+=DiscriminantSpecification*)
	 */
	protected void sequence_KnownDiscriminantPart(ISerializationContext context, KnownDiscriminantPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     identifier=IDENTIFIER
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getLabel_Identifier()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getLabel_Identifier()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getIdentifierIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LabelisableStatement returns LabelisableStatement
	 *
	 * Constraint:
	 *     (labels+=Label* statement=Statement)
	 */
	protected void sequence_LabelisableStatement(ISerializationContext context, LabelisableStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns LibraryUnitDeclaration
	 *     LibraryUnitDeclaration returns LibraryUnitDeclaration
	 *
	 * Constraint:
	 *     (private?=PRIVATE_? libraryUnitSpecification=LibraryUnitSpecification)
	 */
	protected void sequence_LibraryUnitDeclaration(ISerializationContext context, LibraryUnitDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LoopParameterSpecification returns LoopParameterSpecification
	 *
	 * Constraint:
	 *     (identifier=IDENTIFIER discreteSubtypeDefinition=DiscreteSubtypeDefinition)
	 */
	protected void sequence_LoopParameterSpecification(ISerializationContext context, LoopParameterSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getLoopParameterSpecification_Identifier()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getLoopParameterSpecification_Identifier()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getLoopParameterSpecification_DiscreteSubtypeDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getLoopParameterSpecification_DiscreteSubtypeDefinition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopParameterSpecificationAccess().getIdentifierIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getLoopParameterSpecificationAccess().getDiscreteSubtypeDefinitionDiscreteSubtypeDefinitionParserRuleCall_3_0(), semanticObject.getDiscreteSubtypeDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     CompoundStatement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     (name=IDENTIFIER? iterationScheme=IterationScheme? sequenceOfStatements=SequenceOfStatements sameName=IDENTIFIER?)
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Membership returns Membership
	 *
	 * Constraint:
	 *     (not?=NOT_? interval=Interval)
	 */
	protected void sequence_Membership(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModClause returns ModClause
	 *
	 * Constraint:
	 *     mod=Expression
	 */
	protected void sequence_ModClause(ISerializationContext context, ModClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getModClause_Mod()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getModClause_Mod()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModClauseAccess().getModExpressionParserRuleCall_2_0(), semanticObject.getMod());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mode returns Mode
	 *
	 * Constraint:
	 *     (in?=IN_? out?=OUT_?)
	 */
	protected void sequence_Mode(ISerializationContext context, Mode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns ModularTypeDefinition
	 *     IntegerTypeDefinition returns ModularTypeDefinition
	 *     ModularTypeDefinition returns ModularTypeDefinition
	 *
	 * Constraint:
	 *     staticExpression=Expression
	 */
	protected void sequence_ModularTypeDefinition(ISerializationContext context, ModularTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getModularTypeDefinition_StaticExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getModularTypeDefinition_StaticExpression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModularTypeDefinitionAccess().getStaticExpressionExpressionParserRuleCall_1_0(), semanticObject.getStaticExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Interval returns Name
	 *     Name returns Name
	 *
	 * Constraint:
	 *     (name=SelectorName primaryName=PrimaryName?)
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns NamedArrayAggregate
	 *     ParenthesizedExpression returns NamedArrayAggregate
	 *     Qualifier returns NamedArrayAggregate
	 *     Aggregate returns NamedArrayAggregate
	 *     ArrayAggregate returns NamedArrayAggregate
	 *     NamedArrayAggregate returns NamedArrayAggregate
	 *
	 * Constraint:
	 *     (arrayComponentAssociation+=ArrayComponentAssociation arrayComponentAssociation+=ArrayComponentAssociation*)
	 */
	protected void sequence_NamedArrayAggregate(ISerializationContext context, NamedArrayAggregate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NullStatement
	 *     SimpleStatement returns NullStatement
	 *     NullStatement returns NullStatement
	 *
	 * Constraint:
	 *     null?=NULL_
	 */
	protected void sequence_NullStatement(ISerializationContext context, NullStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getNullStatement_Null()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getNullStatement_Null()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullStatementAccess().getNullNULL_TerminalRuleCall_0(), semanticObject.isNull());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns Null
	 *     Null returns Null
	 *
	 * Constraint:
	 *     value=NULL_
	 */
	protected void sequence_Null(ISerializationContext context, Null semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getNull_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getNull_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullAccess().getValueNULL_TerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns NumberDeclaration
	 *     BasicDeclaration returns NumberDeclaration
	 *     DeclarativeItem returns NumberDeclaration
	 *     NumberDeclaration returns NumberDeclaration
	 *
	 * Constraint:
	 *     (idList=DefiningIdentifierList staticExpression=Expression)
	 */
	protected void sequence_NumberDeclaration(ISerializationContext context, NumberDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getNumberDeclaration_IdList()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getNumberDeclaration_IdList()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getNumberDeclaration_StaticExpression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getNumberDeclaration_StaticExpression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDeclarationAccess().getIdListDefiningIdentifierListParserRuleCall_0_0(), semanticObject.getIdList());
		feeder.accept(grammarAccess.getNumberDeclarationAccess().getStaticExpressionExpressionParserRuleCall_4_0(), semanticObject.getStaticExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns NumericLiteral
	 *     NumericLiteral returns NumericLiteral
	 *
	 * Constraint:
	 *     value=NUMERIC_LITERAL
	 */
	protected void sequence_NumericLiteral(ISerializationContext context, NumericLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getNumericLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getNumericLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericLiteralAccess().getValueNUMERIC_LITERALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptConstraint returns OptConstraint
	 *
	 * Constraint:
	 *     (optConstraint=CompositeConstraint | optConstraint=ScalarConstraint)?
	 */
	protected void sequence_OptConstraint(ISerializationContext context, OptConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptNullExclusion returns OptNullExclusion
	 *
	 * Constraint:
	 *     not_null=NullExclusion?
	 */
	protected void sequence_OptNullExclusion(ISerializationContext context, OptNullExclusion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptVariantPart returns OptVariantPart
	 *
	 * Constraint:
	 *     variantPart=VariantPart?
	 */
	protected void sequence_OptVariantPart(ISerializationContext context, OptVariantPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OverridingIndicator returns OverridingIndicator
	 *
	 * Constraint:
	 *     not?=NOT_?
	 */
	protected void sequence_OverridingIndicator(ISerializationContext context, OverridingIndicator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeItem returns PackageBodyStub
	 *     Body returns PackageBodyStub
	 *     BodyStub returns PackageBodyStub
	 *     PackageBodyStub returns PackageBodyStub
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_PackageBodyStub(ISerializationContext context, PackageBodyStub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageBodyStubAccess().getNameIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns PackageBody
	 *     DeclarativeBlock returns PackageBody
	 *     DeclarativeItem returns PackageBody
	 *     Body returns PackageBody
	 *     ProperBody returns PackageBody
	 *     PackageBody returns PackageBody
	 *
	 * Constraint:
	 *     (
	 *         name=[PackageDeclaration|PATHIDENTIFIER] 
	 *         declarativeItems+=DeclarativeItem* 
	 *         handledSequenceOfStatements=HandledSequenceOfStatements? 
	 *         endName=[PackageDeclaration|PATHIDENTIFIER]?
	 *     )
	 */
	protected void sequence_PackageBody(ISerializationContext context, PackageBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns PackageDefinition
	 *     PackageDeclaration returns PackageDefinition
	 *     PackageDefinition returns PackageDefinition
	 *     BasicDeclarativeItem returns PackageDefinition
	 *     BasicDeclaration returns PackageDefinition
	 *     DeclarativeItem returns PackageDefinition
	 *     LibrarySpecification returns PackageDefinition
	 *
	 * Constraint:
	 *     (name=PATHIDENTIFIER packageSpecification=PackageSpecification)
	 */
	protected void sequence_PackageDefinition(ISerializationContext context, PackageDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getPackageDeclaration_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getPackageDeclaration_Name()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getPackageDefinition_PackageSpecification()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getPackageDefinition_PackageSpecification()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageDefinitionAccess().getNamePATHIDENTIFIERParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPackageDefinitionAccess().getPackageSpecificationPackageSpecificationParserRuleCall_3_0(), semanticObject.getPackageSpecification());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PackageSpecification returns PackageSpecification
	 *
	 * Constraint:
	 *     (publicBasicDeclarativeItems+=BasicDeclarativeItem* privateBasicDeclarativeItems+=BasicDeclarativeItem* endname=PATHIDENTIFIER?)
	 */
	protected void sequence_PackageSpecification(ISerializationContext context, PackageSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterAndResultProfile returns ParameterAndResultProfile
	 *
	 * Constraint:
	 *     (formalPart=FormalPart? ((opt_nullExclusion=OptNullExclusion subtypeMark=Name) | anonymousAccessDefinition=AnonymousAccessDefinition))
	 */
	protected void sequence_ParameterAndResultProfile(ISerializationContext context, ParameterAndResultProfile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterAssociation returns ParameterAssociation
	 *
	 * Constraint:
	 *     (selectorName=SelectorName? parameterEffectiveValue=ParameterEffectiveValue)
	 */
	protected void sequence_ParameterAssociation(ISerializationContext context, ParameterAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterSpecification returns ParameterSpecification
	 *
	 * Constraint:
	 *     (
	 *         definingIdentifiers=DefiningIdentifierList 
	 *         ((mode=Mode optNullExclusion=OptNullExclusion subtypeMark=Name) | anonymousAccessDefinition=AnonymousAccessDefinition) 
	 *         defaultExpression=Expression?
	 *     )
	 */
	protected void sequence_ParameterSpecification(ISerializationContext context, ParameterSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns PositionalArrayAggregate
	 *     ParenthesizedExpression returns PositionalArrayAggregate
	 *     Qualifier returns PositionalArrayAggregate
	 *     Aggregate returns PositionalArrayAggregate
	 *     ArrayAggregate returns PositionalArrayAggregate
	 *     PositionalArrayAggregate returns PositionalArrayAggregate
	 *
	 * Constraint:
	 *     (initialValues+=Expression initialValues+=Expression+ (othersValue=Expression | othersBox?=BOIT)?)
	 */
	protected void sequence_PositionalArrayAggregate(ISerializationContext context, PositionalArrayAggregate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PragmaArgumentAssociation returns PragmaArgumentAssociation
	 *
	 * Constraint:
	 *     (name=IDENTIFIER? effectiveArgument=Expression)
	 */
	protected void sequence_PragmaArgumentAssociation(ISerializationContext context, PragmaArgumentAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextItem returns Pragma
	 *     BasicDeclarativeItem returns Pragma
	 *     DeclarativeItem returns Pragma
	 *     Statement returns Pragma
	 *     Pragma returns Pragma
	 *
	 * Constraint:
	 *     (name=IDENTIFIER (pragmaArgumentAssociation+=PragmaArgumentAssociation pragmaArgumentAssociation+=PragmaArgumentAssociation*)?)
	 */
	protected void sequence_Pragma(ISerializationContext context, Pragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryName returns PrimaryName
	 *
	 * Constraint:
	 *     (
	 *         (parameterAssociation+=ParameterAssociation parameterAssociation+=ParameterAssociation* primaryName=PrimaryName?) | 
	 *         name=Name | 
	 *         attributeDesignator=AttributeDesignator
	 *     )?
	 */
	protected void sequence_PrimaryName(ISerializationContext context, PrimaryName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns PrivateExtensionDeclaration
	 *     BasicDeclaration returns PrivateExtensionDeclaration
	 *     TypeDeclaration returns PrivateExtensionDeclaration
	 *     NewTypeDeclaration returns PrivateExtensionDeclaration
	 *     PrivateExtensionDeclaration returns PrivateExtensionDeclaration
	 *     DeclarativeItem returns PrivateExtensionDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=IDENTIFIER 
	 *         discriminantPart=DiscriminantPart? 
	 *         abstract?=ABSTRACT_? 
	 *         (limited?=LIMITED_ | synchronized?=SYNCHRONIZED_)? 
	 *         ancestorSubtypeIndication=SubtypeIndication 
	 *         interfaceList=InterfaceList?
	 *     )
	 */
	protected void sequence_PrivateExtensionDeclaration(ISerializationContext context, PrivateExtensionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns PrivateTypeDeclaration
	 *     BasicDeclaration returns PrivateTypeDeclaration
	 *     TypeDeclaration returns PrivateTypeDeclaration
	 *     NewTypeDeclaration returns PrivateTypeDeclaration
	 *     PrivateTypeDeclaration returns PrivateTypeDeclaration
	 *     DeclarativeItem returns PrivateTypeDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER discriminantPart=DiscriminantPart? (abstract?=ABSTRACT_? tagged?=TAGGED_)? limited?=LIMITED_?)
	 */
	protected void sequence_PrivateTypeDeclaration(ISerializationContext context, PrivateTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ProcedureOrEntryCallStatement
	 *     SimpleStatement returns ProcedureOrEntryCallStatement
	 *     ProcedureOrEntryCallStatement returns ProcedureOrEntryCallStatement
	 *     TriggeringStatement returns ProcedureOrEntryCallStatement
	 *
	 * Constraint:
	 *     callee=Name
	 */
	protected void sequence_ProcedureOrEntryCallStatement(ISerializationContext context, ProcedureOrEntryCallStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getProcedureOrEntryCallStatement_Callee()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getProcedureOrEntryCallStatement_Callee()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcedureOrEntryCallStatementAccess().getCalleeNameParserRuleCall_0(), semanticObject.getCallee());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns ProcedureSpecification
	 *     SubprogramSpecification returns ProcedureSpecification
	 *     ProcedureSpecification returns ProcedureSpecification
	 *     DeclarativeItem returns ProcedureSpecification
	 *     Body returns ProcedureSpecification
	 *     LibrarySpecification returns ProcedureSpecification
	 *     BodyStub returns ProcedureSpecification
	 *
	 * Constraint:
	 *     (overridingIndicator=OverridingIndicator? name=IDENTIFIER formalPart=FormalPart?)
	 */
	protected void sequence_ProcedureSpecification(ISerializationContext context, ProcedureSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeItem returns ProtectedBodyStub
	 *     Body returns ProtectedBodyStub
	 *     BodyStub returns ProtectedBodyStub
	 *     ProtectedBodyStub returns ProtectedBodyStub
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_ProtectedBodyStub(ISerializationContext context, ProtectedBodyStub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProtectedBodyStubAccess().getNameIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeItem returns ProtectedBody
	 *     Body returns ProtectedBody
	 *     ProperBody returns ProtectedBody
	 *     ProtectedBody returns ProtectedBody
	 *
	 * Constraint:
	 *     (identifier=IDENTIFIER protectedOperationItem+=ProtectedOperationItem* idTask=IDENTIFIER?)
	 */
	protected void sequence_ProtectedBody(ISerializationContext context, ProtectedBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProtectedDefinition returns ProtectedDefinition
	 *
	 * Constraint:
	 *     (protectedOperationDeclaration+=ProtectedOperationDeclaration* protectedOperationDeclaration+=ProtectedElementDeclaration*)
	 */
	protected void sequence_ProtectedDefinition(ISerializationContext context, ProtectedDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns ProtectedTypeDeclaration
	 *     BasicDeclaration returns ProtectedTypeDeclaration
	 *     TypeDeclaration returns ProtectedTypeDeclaration
	 *     NewTypeDeclaration returns ProtectedTypeDeclaration
	 *     FullTypeDeclaration returns ProtectedTypeDeclaration
	 *     ProtectedTypeDeclaration returns ProtectedTypeDeclaration
	 *     DeclarativeItem returns ProtectedTypeDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER knownDiscriminantPart=KnownDiscriminantPart? interfaceList=InterfaceList? protectedDefinition=ProtectedDefinition)
	 */
	protected void sequence_ProtectedTypeDeclaration(ISerializationContext context, ProtectedTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns QualifiedName
	 *     QualifiedName returns QualifiedName
	 *
	 * Constraint:
	 *     (name=Name qualifier=Qualifier?)
	 */
	protected void sequence_QualifiedName(ISerializationContext context, QualifiedName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RaiseStatement
	 *     SimpleStatement returns RaiseStatement
	 *     RaiseStatement returns RaiseStatement
	 *
	 * Constraint:
	 *     (exceptionName=Name withExpression=Expression?)?
	 */
	protected void sequence_RaiseStatement(ISerializationContext context, RaiseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RealRangeSpecification returns RealRangeSpecification
	 *
	 * Constraint:
	 *     (lowerBound=SimpleExpression upperBound=SimpleExpression)
	 */
	protected void sequence_RealRangeSpecification(ISerializationContext context, RealRangeSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getRealRangeSpecification_LowerBound()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getRealRangeSpecification_LowerBound()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getRealRangeSpecification_UpperBound()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getRealRangeSpecification_UpperBound()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealRangeSpecificationAccess().getLowerBoundSimpleExpressionParserRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getRealRangeSpecificationAccess().getUpperBoundSimpleExpressionParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns RecordComponentAssociationList
	 *     ParenthesizedExpression returns RecordComponentAssociationList
	 *     Qualifier returns RecordComponentAssociationList
	 *     Aggregate returns RecordComponentAssociationList
	 *     RecordAggregate returns RecordComponentAssociationList
	 *     RecordComponentAssociationList returns RecordComponentAssociationList
	 *
	 * Constraint:
	 *     ((recordComponentAssociation+=RecordComponentAssociation recordComponentAssociation+=RecordComponentAssociation*) | nullRecord?=NULL_)
	 */
	protected void sequence_RecordComponentAssociationList(ISerializationContext context, RecordComponentAssociationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecordDefinition returns RecordDefinition
	 *
	 * Constraint:
	 *     (componentList=ComponentList | null=NULL_ | null=NULL_)
	 */
	protected void sequence_RecordDefinition(ISerializationContext context, RecordDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecordExtensionPart returns RecordExtensionPart
	 *
	 * Constraint:
	 *     recordDefinition=RecordDefinition
	 */
	protected void sequence_RecordExtensionPart(ISerializationContext context, RecordExtensionPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getRecordExtensionPart_RecordDefinition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getRecordExtensionPart_RecordDefinition()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordExtensionPartAccess().getRecordDefinitionRecordDefinitionParserRuleCall_1_0(), semanticObject.getRecordDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns RecordTypeDefinition
	 *     RecordTypeDefinition returns RecordTypeDefinition
	 *
	 * Constraint:
	 *     ((abstract?=ABSTRACT_? tagged?=TAGGED_)? limited?=LIMITED_? recordDefinition=RecordDefinition)
	 */
	protected void sequence_RecordTypeDefinition(ISerializationContext context, RecordTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (simpleExpression=SimpleExpression ((relationalOperator=RelationalOperator subSimpleExpression=SimpleExpression) | membership=Membership)?)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryUnitSpecification returns Renaming
	 *     PackageDeclaration returns Renaming
	 *     Renaming returns Renaming
	 *     BasicDeclarativeItem returns Renaming
	 *     BasicDeclaration returns Renaming
	 *     DeclarativeItem returns Renaming
	 *
	 * Constraint:
	 *     (name=PATHIDENTIFIER renamed=PATHIDENTIFIER)
	 */
	protected void sequence_Renaming(ISerializationContext context, Renaming semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getPackageDeclaration_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getPackageDeclaration_Name()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getRenaming_Renamed()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getRenaming_Renamed()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRenamingAccess().getNamePATHIDENTIFIERParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRenamingAccess().getRenamedPATHIDENTIFIERParserRuleCall_3_0(), semanticObject.getRenamed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RequeueStatement
	 *     SimpleStatement returns RequeueStatement
	 *     RequeueStatement returns RequeueStatement
	 *
	 * Constraint:
	 *     (name=Name abort?=WITH_?)
	 */
	protected void sequence_RequeueStatement(ISerializationContext context, RequeueStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectAlternative returns SelectAlternative
	 *
	 * Constraint:
	 *     {SelectAlternative}
	 */
	protected void sequence_SelectAlternative(ISerializationContext context, SelectAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelectiveAccept
	 *     CompoundStatement returns SelectiveAccept
	 *     SelectStatement returns SelectiveAccept
	 *     SelectiveAccept returns SelectiveAccept
	 *
	 * Constraint:
	 *     (selectguard=Guard? selectAlternative=SelectAlternative guardedAlternatives+=GuardedAlternative* elseStatements=SequenceOfStatements?)
	 */
	protected void sequence_SelectiveAccept(ISerializationContext context, SelectiveAccept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns SeparateSubunit
	 *     SeparateSubunit returns SeparateSubunit
	 *
	 * Constraint:
	 *     (parentUnitName=PATHIDENTIFIER properBody=ProperBody)
	 */
	protected void sequence_SeparateSubunit(ISerializationContext context, SeparateSubunit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSeparateSubunit_ParentUnitName()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSeparateSubunit_ParentUnitName()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSeparateSubunit_ProperBody()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSeparateSubunit_ProperBody()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeparateSubunitAccess().getParentUnitNamePATHIDENTIFIERParserRuleCall_2_0(), semanticObject.getParentUnitName());
		feeder.accept(grammarAccess.getSeparateSubunitAccess().getProperBodyProperBodyParserRuleCall_4_0(), semanticObject.getProperBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SequenceOfStatements returns SequenceOfStatements
	 *     AbortablePart returns SequenceOfStatements
	 *
	 * Constraint:
	 *     statements+=LabelisableStatement+
	 */
	protected void sequence_SequenceOfStatements(ISerializationContext context, SequenceOfStatements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns SignedIntegerTypeDefinition
	 *     IntegerTypeDefinition returns SignedIntegerTypeDefinition
	 *     SignedIntegerTypeDefinition returns SignedIntegerTypeDefinition
	 *
	 * Constraint:
	 *     (first=SimpleExpression last=SimpleExpression)
	 */
	protected void sequence_SignedIntegerTypeDefinition(ISerializationContext context, SignedIntegerTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSignedIntegerTypeDefinition_First()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSignedIntegerTypeDefinition_First()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSignedIntegerTypeDefinition_Last()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSignedIntegerTypeDefinition_Last()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignedIntegerTypeDefinitionAccess().getFirstSimpleExpressionParserRuleCall_1_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getSignedIntegerTypeDefinitionAccess().getLastSimpleExpressionParserRuleCall_3_0(), semanticObject.getLast());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns SimpleExpression
	 *
	 * Constraint:
	 *     (unaryAddingOperator=UnaryAddingOperator? terms+=Term (binaryAddingOperators+=BinaryAddingOperator terms+=Term)*)
	 */
	protected void sequence_SimpleExpression(ISerializationContext context, SimpleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SimpleReturnStatement
	 *     SimpleStatement returns SimpleReturnStatement
	 *     SimpleReturnStatement returns SimpleReturnStatement
	 *
	 * Constraint:
	 *     returnValue=Expression?
	 */
	protected void sequence_SimpleReturnStatement(ISerializationContext context, SimpleReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns SingleProtectedDeclaration
	 *     BasicDeclaration returns SingleProtectedDeclaration
	 *     DeclarativeItem returns SingleProtectedDeclaration
	 *     ObjectDeclaration returns SingleProtectedDeclaration
	 *     SingleProtectedDeclaration returns SingleProtectedDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER interfaceList=InterfaceList? protectedDefinition=ProtectedDefinition)
	 */
	protected void sequence_SingleProtectedDeclaration(ISerializationContext context, SingleProtectedDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getStringLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getStringLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRING_LITERALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns SubprogramBody
	 *     SubprogramBody returns SubprogramBody
	 *     DeclarativeBlock returns SubprogramBody
	 *     DeclarativeItem returns SubprogramBody
	 *     Body returns SubprogramBody
	 *     ProperBody returns SubprogramBody
	 *     ProtectedOperationItem returns SubprogramBody
	 *
	 * Constraint:
	 *     (
	 *         subprogramSpecification=SubprogramSpecification 
	 *         declarativeItems+=DeclarativeItem* 
	 *         handledSequenceOfStatements=HandledSequenceOfStatements 
	 *         endname=PATHNAME?
	 *     )
	 */
	protected void sequence_SubprogramBody(ISerializationContext context, SubprogramBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns SubprogramDeclaration
	 *     BasicDeclaration returns SubprogramDeclaration
	 *     ProtectedElementDeclaration returns SubprogramDeclaration
	 *     ProtectedOperationDeclaration returns SubprogramDeclaration
	 *     SubprogramDeclaration returns SubprogramDeclaration
	 *     DeclarativeItem returns SubprogramDeclaration
	 *     ProtectedOperationItem returns SubprogramDeclaration
	 *
	 * Constraint:
	 *     (subprogramSpecification=SubprogramSpecification (abstract?=ABSTRACT_ | renamedName=PATHNAME | null?=NULL_)?)
	 */
	protected void sequence_SubprogramDeclaration(ISerializationContext context, SubprogramDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubprogramDefault returns SubprogramDefault
	 *
	 * Constraint:
	 *     defaultName=PATHNAME?
	 */
	protected void sequence_SubprogramDefault(ISerializationContext context, SubprogramDefault semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns SubtypeDeclaration
	 *     BasicDeclaration returns SubtypeDeclaration
	 *     TypeDeclaration returns SubtypeDeclaration
	 *     DeclarativeItem returns SubtypeDeclaration
	 *     SubtypeDeclaration returns SubtypeDeclaration
	 *
	 * Constraint:
	 *     (name=IDENTIFIER subtypeIndication=SubtypeIndication)
	 */
	protected void sequence_SubtypeDeclaration(ISerializationContext context, SubtypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getTypeDeclaration_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getTypeDeclaration_Name()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSubtypeDeclaration_SubtypeIndication()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSubtypeDeclaration_SubtypeIndication()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtypeDeclarationAccess().getNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSubtypeDeclarationAccess().getSubtypeIndicationSubtypeIndicationParserRuleCall_3_0(), semanticObject.getSubtypeIndication());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReturnSubtypeIndication returns SubtypeIndication
	 *     DiscreteSubtypeDefinition returns SubtypeIndication
	 *     SubtypeIndication returns SubtypeIndication
	 *     DiscreteRange returns SubtypeIndication
	 *     DiscreteChoice returns SubtypeIndication
	 *
	 * Constraint:
	 *     (opt_nullExclusion=OptNullExclusion subtypeMark=PATHIDENTIFIER opt_constraint=OptConstraint)
	 */
	protected void sequence_SubtypeIndication(ISerializationContext context, SubtypeIndication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_Opt_nullExclusion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_Opt_nullExclusion()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_SubtypeMark()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_SubtypeMark()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_Opt_constraint()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getSubtypeIndication_Opt_constraint()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtypeIndicationAccess().getOpt_nullExclusionOptNullExclusionParserRuleCall_0_0(), semanticObject.getOpt_nullExclusion());
		feeder.accept(grammarAccess.getSubtypeIndicationAccess().getSubtypeMarkPATHIDENTIFIERParserRuleCall_1_0(), semanticObject.getSubtypeMark());
		feeder.accept(grammarAccess.getSubtypeIndicationAccess().getOpt_constraintOptConstraintParserRuleCall_2_0(), semanticObject.getOpt_constraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeItem returns TaskBodyStub
	 *     Body returns TaskBodyStub
	 *     BodyStub returns TaskBodyStub
	 *     TaskBodyStub returns TaskBodyStub
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_TaskBodyStub(ISerializationContext context, TaskBodyStub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getBodyStub_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskBodyStubAccess().getNameIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarativeBlock returns TaskBody
	 *     DeclarativeItem returns TaskBody
	 *     Body returns TaskBody
	 *     ProperBody returns TaskBody
	 *     TaskBody returns TaskBody
	 *
	 * Constraint:
	 *     (
	 *         name=[TaskDeclaration|IDENTIFIER] 
	 *         declarativeItems+=DeclarativeItem* 
	 *         handledSequenceOfStatements=HandledSequenceOfStatements 
	 *         endId=[TaskDeclaration|IDENTIFIER]?
	 *     )
	 */
	protected void sequence_TaskBody(ISerializationContext context, TaskBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicDeclarativeItem returns TaskDeclaration
	 *     BasicDeclaration returns TaskDeclaration
	 *     TaskDeclaration returns TaskDeclaration
	 *     DeclarativeItem returns TaskDeclaration
	 *
	 * Constraint:
	 *     (
	 *         ((name=IDENTIFIER knownDiscriminantPart=KnownDiscriminantPart?) | name=IDENTIFIER) 
	 *         (interfaceList=InterfaceList? taskDefinition=TaskDefinition endid=[TaskDeclaration|IDENTIFIER]?)?
	 *     )
	 */
	protected void sequence_TaskDeclaration(ISerializationContext context, TaskDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TaskDefinition returns TaskDefinition
	 *
	 * Constraint:
	 *     (taskItems+=TaskItem* taskItems+=TaskItem*)
	 */
	protected void sequence_TaskDefinition(ISerializationContext context, TaskDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TaskNames
	 *     SimpleStatement returns TaskNames
	 *     AbortStatement returns TaskNames
	 *     TaskNames returns TaskNames
	 *
	 * Constraint:
	 *     (taskNames+=Name taskNames+=Name*)
	 */
	protected void sequence_TaskNames(ISerializationContext context, TaskNames semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (factors+=Factor (multiplyingOperators+=MultiplyingOperator factors+=Factor)*)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TimedEntryCall
	 *     CompoundStatement returns TimedEntryCall
	 *     SelectStatement returns TimedEntryCall
	 *     TimedEntryCall returns TimedEntryCall
	 *
	 * Constraint:
	 *     (entryCallAlternative=EntryCallAlternative delayAlternative=DelayAlternative)
	 */
	protected void sequence_TimedEntryCall(ISerializationContext context, TimedEntryCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getTimedEntryCall_EntryCallAlternative()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getTimedEntryCall_EntryCallAlternative()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getTimedEntryCall_DelayAlternative()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getTimedEntryCall_DelayAlternative()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimedEntryCallAccess().getEntryCallAlternativeEntryCallAlternativeParserRuleCall_1_0(), semanticObject.getEntryCallAlternative());
		feeder.accept(grammarAccess.getTimedEntryCallAccess().getDelayAlternativeDelayAlternativeParserRuleCall_4_0(), semanticObject.getDelayAlternative());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TriggeringAlternative returns TriggeringAlternative
	 *
	 * Constraint:
	 *     (triggeringStatement=TriggeringStatement sequenceOfStatements=SequenceOfStatements?)
	 */
	protected void sequence_TriggeringAlternative(ISerializationContext context, TriggeringAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayIndexes returns UnconstrainedIndexes
	 *     UnconstrainedIndexes returns UnconstrainedIndexes
	 *
	 * Constraint:
	 *     (subtypeMark+=Name subtypeMark+=Name*)
	 */
	protected void sequence_UnconstrainedIndexes(ISerializationContext context, UnconstrainedIndexes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecordComponentAssociation returns UninitializedComponents
	 *     UninitializedComponents returns UninitializedComponents
	 *
	 * Constraint:
	 *     (componentChoiceList+=ComponentChoiceList box?=BOIT)
	 */
	protected void sequence_UninitializedComponents(ISerializationContext context, UninitializedComponents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DiscriminantPart returns UnknownDiscriminantPart
	 *     UnknownDiscriminantPart returns UnknownDiscriminantPart
	 *
	 * Constraint:
	 *     box?=BOIT
	 */
	protected void sequence_UnknownDiscriminantPart(ISerializationContext context, UnknownDiscriminantPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getUnknownDiscriminantPart_Box()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getUnknownDiscriminantPart_Box()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnknownDiscriminantPartAccess().getBoxBOITTerminalRuleCall_1_0(), semanticObject.isBox());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextItem returns UsePackageClause
	 *     UseClause returns UsePackageClause
	 *     UsePackageClause returns UsePackageClause
	 *     BasicDeclarativeItem returns UsePackageClause
	 *     DeclarativeItem returns UsePackageClause
	 *     GenericItem returns UsePackageClause
	 *
	 * Constraint:
	 *     (importedNamespace+=[LibraryUnitDeclaration|PATHIDENTIFIER] importedNamespace+=[LibraryUnitDeclaration|PATHIDENTIFIER]*)
	 */
	protected void sequence_UsePackageClause(ISerializationContext context, UsePackageClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextItem returns UseTypeClause
	 *     UseClause returns UseTypeClause
	 *     UseTypeClause returns UseTypeClause
	 *     BasicDeclarativeItem returns UseTypeClause
	 *     DeclarativeItem returns UseTypeClause
	 *     GenericItem returns UseTypeClause
	 *
	 * Constraint:
	 *     (typesNames+=PATHIDENTIFIER useTypeRefs+=PATHIDENTIFIER*)
	 */
	protected void sequence_UseTypeClause(ISerializationContext context, UseTypeClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariantPart returns VariantPart
	 *
	 * Constraint:
	 *     (name=DIRECT_NAME variants+=Variant+)
	 */
	protected void sequence_VariantPart(ISerializationContext context, VariantPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variant returns Variant
	 *
	 * Constraint:
	 *     (discreteChoiceList=DiscreteChoiceList componentList=ComponentList)
	 */
	protected void sequence_Variant(ISerializationContext context, Variant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getVariant_DiscreteChoiceList()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getVariant_DiscreteChoiceList()));
			if (transientValues.isValueTransient(semanticObject, AdbPackage.eINSTANCE.getVariant_ComponentList()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AdbPackage.eINSTANCE.getVariant_ComponentList()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAccess().getDiscreteChoiceListDiscreteChoiceListParserRuleCall_1_0(), semanticObject.getDiscreteChoiceList());
		feeder.accept(grammarAccess.getVariantAccess().getComponentListComponentListParserRuleCall_3_0(), semanticObject.getComponentList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextItem returns WithClause
	 *     WithClause returns WithClause
	 *
	 * Constraint:
	 *     (limited?=LIMITED_? private?=PRIVATE_? importURI+=[LibraryUnitDeclaration|PATHIDENTIFIER] importURI+=[LibraryUnitDeclaration|PATHIDENTIFIER]*)
	 */
	protected void sequence_WithClause(ISerializationContext context, WithClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
