/*
 * generated by Xtext
 */
package org.xtext.ada2005.serializer;

import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AlternativeAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.GroupAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;
import org.xtext.ada2005.services.AdbGrammarAccess;

@SuppressWarnings("all")
public class AdbSyntacticSequencer extends AbstractSyntacticSequencer {

	protected AdbGrammarAccess grammarAccess;
	protected AbstractElementAlias match_AttributeDesignator_ACCESS_TerminalRuleCall_1_1_or_DELTA_TerminalRuleCall_1_2_or_DIGITS_TerminalRuleCall_1_3_or_IDENTIFIERTerminalRuleCall_1_0_0;
	protected AbstractElementAlias match_BlockStatement_DECLARE_TerminalRuleCall_1_0_q;
	protected AbstractElementAlias match_BlockStatement_IDENTIFIERTerminalRuleCall_5_q;
	protected AbstractElementAlias match_ExtendedReturnStatement_ALIASED_TerminalRuleCall_3_q;
	protected AbstractElementAlias match_FormalDerivedTypeDefinition___WITH_TerminalRuleCall_4_1_PRIVATE_TerminalRuleCall_4_2__q;
	protected AbstractElementAlias match_FormalPackageActualPart___OTHERS_TerminalRuleCall_1_0_1_0_FLECHETerminalRuleCall_1_0_1_1__q;
	protected AbstractElementAlias match_FormalPackageActualPart___VTerminalRuleCall_1_2_3_0_OTHERS_TerminalRuleCall_1_2_3_1_FLECHETerminalRuleCall_1_2_3_2_BOITTerminalRuleCall_1_2_3_3__q;
	protected AbstractElementAlias match_FormalTypeDefinition_FormalDecimalFixedPointDefinitionParserRuleCall_7_1_or_FormalDiscreteTypeDefinitionParserRuleCall_2_1_or_FormalFloatingPointDefinitionParserRuleCall_5_1_or_FormalModularTypeDefinitionParserRuleCall_4_1_or_FormalOrdinaryFixedPointDefinitionParserRuleCall_6_1_or_FormalSignedIntegerTypeDefinitionParserRuleCall_3_1;
	protected AbstractElementAlias match_LoopParameterSpecification_REVERSE_TerminalRuleCall_2_q;
	protected AbstractElementAlias match_PackageSpecification_PRIVATE_TerminalRuleCall_2_0_q;
	protected AbstractElementAlias match_ProtectedDefinition_IDENTIFIERTerminalRuleCall_4_q;
	protected AbstractElementAlias match_ProtectedDefinition_PRIVATE_TerminalRuleCall_2_0_q;
	protected AbstractElementAlias match_SubprogramDefault_BOITTerminalRuleCall_1_1_or_NULL_TerminalRuleCall_1_2;
	protected AbstractElementAlias match_TaskDefinition_PRIVATE_TerminalRuleCall_2_0_q;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (AdbGrammarAccess) access;
		match_AttributeDesignator_ACCESS_TerminalRuleCall_1_1_or_DELTA_TerminalRuleCall_1_2_or_DIGITS_TerminalRuleCall_1_3_or_IDENTIFIERTerminalRuleCall_1_0_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getAttributeDesignatorAccess().getACCESS_TerminalRuleCall_1_1()), new TokenAlias(false, false, grammarAccess.getAttributeDesignatorAccess().getDELTA_TerminalRuleCall_1_2()), new TokenAlias(false, false, grammarAccess.getAttributeDesignatorAccess().getDIGITS_TerminalRuleCall_1_3()), new TokenAlias(false, false, grammarAccess.getAttributeDesignatorAccess().getIDENTIFIERTerminalRuleCall_1_0_0()));
		match_BlockStatement_DECLARE_TerminalRuleCall_1_0_q = new TokenAlias(false, true, grammarAccess.getBlockStatementAccess().getDECLARE_TerminalRuleCall_1_0());
		match_BlockStatement_IDENTIFIERTerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getBlockStatementAccess().getIDENTIFIERTerminalRuleCall_5());
		match_ExtendedReturnStatement_ALIASED_TerminalRuleCall_3_q = new TokenAlias(false, true, grammarAccess.getExtendedReturnStatementAccess().getALIASED_TerminalRuleCall_3());
		match_FormalDerivedTypeDefinition___WITH_TerminalRuleCall_4_1_PRIVATE_TerminalRuleCall_4_2__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getFormalDerivedTypeDefinitionAccess().getWITH_TerminalRuleCall_4_1()), new TokenAlias(false, false, grammarAccess.getFormalDerivedTypeDefinitionAccess().getPRIVATE_TerminalRuleCall_4_2()));
		match_FormalPackageActualPart___OTHERS_TerminalRuleCall_1_0_1_0_FLECHETerminalRuleCall_1_0_1_1__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getOTHERS_TerminalRuleCall_1_0_1_0()), new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getFLECHETerminalRuleCall_1_0_1_1()));
		match_FormalPackageActualPart___VTerminalRuleCall_1_2_3_0_OTHERS_TerminalRuleCall_1_2_3_1_FLECHETerminalRuleCall_1_2_3_2_BOITTerminalRuleCall_1_2_3_3__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getVTerminalRuleCall_1_2_3_0()), new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getOTHERS_TerminalRuleCall_1_2_3_1()), new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getFLECHETerminalRuleCall_1_2_3_2()), new TokenAlias(false, false, grammarAccess.getFormalPackageActualPartAccess().getBOITTerminalRuleCall_1_2_3_3()));
		match_FormalTypeDefinition_FormalDecimalFixedPointDefinitionParserRuleCall_7_1_or_FormalDiscreteTypeDefinitionParserRuleCall_2_1_or_FormalFloatingPointDefinitionParserRuleCall_5_1_or_FormalModularTypeDefinitionParserRuleCall_4_1_or_FormalOrdinaryFixedPointDefinitionParserRuleCall_6_1_or_FormalSignedIntegerTypeDefinitionParserRuleCall_3_1 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalDecimalFixedPointDefinitionParserRuleCall_7_1()), new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalDiscreteTypeDefinitionParserRuleCall_2_1()), new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalFloatingPointDefinitionParserRuleCall_5_1()), new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalModularTypeDefinitionParserRuleCall_4_1()), new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalOrdinaryFixedPointDefinitionParserRuleCall_6_1()), new TokenAlias(false, false, grammarAccess.getFormalTypeDefinitionAccess().getFormalSignedIntegerTypeDefinitionParserRuleCall_3_1()));
		match_LoopParameterSpecification_REVERSE_TerminalRuleCall_2_q = new TokenAlias(false, true, grammarAccess.getLoopParameterSpecificationAccess().getREVERSE_TerminalRuleCall_2());
		match_PackageSpecification_PRIVATE_TerminalRuleCall_2_0_q = new TokenAlias(false, true, grammarAccess.getPackageSpecificationAccess().getPRIVATE_TerminalRuleCall_2_0());
		match_ProtectedDefinition_IDENTIFIERTerminalRuleCall_4_q = new TokenAlias(false, true, grammarAccess.getProtectedDefinitionAccess().getIDENTIFIERTerminalRuleCall_4());
		match_ProtectedDefinition_PRIVATE_TerminalRuleCall_2_0_q = new TokenAlias(false, true, grammarAccess.getProtectedDefinitionAccess().getPRIVATE_TerminalRuleCall_2_0());
		match_SubprogramDefault_BOITTerminalRuleCall_1_1_or_NULL_TerminalRuleCall_1_2 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getSubprogramDefaultAccess().getBOITTerminalRuleCall_1_1()), new TokenAlias(false, false, grammarAccess.getSubprogramDefaultAccess().getNULL_TerminalRuleCall_1_2()));
		match_TaskDefinition_PRIVATE_TerminalRuleCall_2_0_q = new TokenAlias(false, true, grammarAccess.getTaskDefinitionAccess().getPRIVATE_TerminalRuleCall_2_0());
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getABORT_Rule())
			return getABORT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getABSTRACT_Rule())
			return getABSTRACT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getABS_Rule())
			return getABS_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getACCEPT_Rule())
			return getACCEPT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getACCESS_Rule())
			return getACCESS_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getALIASED_Rule())
			return getALIASED_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getALL_Rule())
			return getALL_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getAND_Rule())
			return getAND_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getARRAY_Rule())
			return getARRAY_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getAT_Rule())
			return getAT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getBEGIN_Rule())
			return getBEGIN_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getBODY_Rule())
			return getBODY_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getBOITRule())
			return getBOITToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getBVRule())
			return getBVToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCASE_Rule())
			return getCASE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCHDRule())
			return getCHDToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCHGRule())
			return getCHGToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCONSTANT_Rule())
			return getCONSTANT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDECLARE_Rule())
			return getDECLARE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDELAY_Rule())
			return getDELAY_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDELTA_Rule())
			return getDELTA_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDIGITS_Rule())
			return getDIGITS_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDO_Rule())
			return getDO_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDPRule())
			return getDPToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDPERule())
			return getDPEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getELSE_Rule())
			return getELSE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getELSIF_Rule())
			return getELSIF_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getEND_Rule())
			return getEND_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getENTRY_Rule())
			return getENTRY_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getETOI2Rule())
			return getETOI2Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getEXCEPTION_Rule())
			return getEXCEPTION_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getEXIT_Rule())
			return getEXIT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFLECHERule())
			return getFLECHEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFOR_Rule())
			return getFOR_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFUNCTION_Rule())
			return getFUNCTION_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalDecimalFixedPointDefinitionRule())
			return getFormalDecimalFixedPointDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalDiscreteTypeDefinitionRule())
			return getFormalDiscreteTypeDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalFloatingPointDefinitionRule())
			return getFormalFloatingPointDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalModularTypeDefinitionRule())
			return getFormalModularTypeDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalOrdinaryFixedPointDefinitionRule())
			return getFormalOrdinaryFixedPointDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFormalSignedIntegerTypeDefinitionRule())
			return getFormalSignedIntegerTypeDefinitionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getGENERIC_Rule())
			return getGENERIC_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getGOTO_Rule())
			return getGOTO_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIDENTIFIERRule())
			return getIDENTIFIERToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIF_Rule())
			return getIF_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getINTERFACE_Rule())
			return getINTERFACE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIN_Rule())
			return getIN_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIS_Rule())
			return getIS_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getLIMITED_Rule())
			return getLIMITED_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getLOOP_Rule())
			return getLOOP_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getMOD_Rule())
			return getMOD_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getNEW_Rule())
			return getNEW_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getNOT_Rule())
			return getNOT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getNULL_Rule())
			return getNULL_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOF_Rule())
			return getOF_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOR_Rule())
			return getOR_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOTHERS_Rule())
			return getOTHERS_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOUT_Rule())
			return getOUT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOVERRIDING_Rule())
			return getOVERRIDING_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPRule())
			return getPToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPACKAGE_Rule())
			return getPACKAGE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPDRule())
			return getPDToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPGRule())
			return getPGToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPPRule())
			return getPPToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPRAGMA_Rule())
			return getPRAGMA_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPRIVATE_Rule())
			return getPRIVATE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPROCEDURE_Rule())
			return getPROCEDURE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPROTECTED_Rule())
			return getPROTECTED_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPVRule())
			return getPVToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getQUOTERule())
			return getQUOTEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRAISE_Rule())
			return getRAISE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRANGE_Rule())
			return getRANGE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRECORD_Rule())
			return getRECORD_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRENAMES_Rule())
			return getRENAMES_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getREQUEUE_Rule())
			return getREQUEUE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRETURN_Rule())
			return getRETURN_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getREVERSE_Rule())
			return getREVERSE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSELECT_Rule())
			return getSELECT_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSEPARATE_Rule())
			return getSEPARATE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSUBTYPE_Rule())
			return getSUBTYPE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSYNCHRONIZED_Rule())
			return getSYNCHRONIZED_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTAGGED_Rule())
			return getTAGGED_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTASK_Rule())
			return getTASK_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTERMINATE_Rule())
			return getTERMINATE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTHEN_Rule())
			return getTHEN_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTYPE_Rule())
			return getTYPE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getUSE_Rule())
			return getUSE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getVRule())
			return getVToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getWHEN_Rule())
			return getWHEN_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getWHILE_Rule())
			return getWHILE_Token(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getWITH_Rule())
			return getWITH_Token(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * terminal ABORT_: "abort" ;
	 */
	protected String getABORT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "abort";
	}
	
	/**
	 * terminal ABSTRACT_: "abstract" ;
	 */
	protected String getABSTRACT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "abstract";
	}
	
	/**
	 * terminal ABS_: "abs" ;
	 */
	protected String getABS_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "abs";
	}
	
	/**
	 * terminal ACCEPT_: "accept" ;
	 */
	protected String getACCEPT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "accept";
	}
	
	/**
	 * terminal ACCESS_: "access" ;
	 */
	protected String getACCESS_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "access";
	}
	
	/**
	 * terminal ALIASED_: "aliased" ;
	 */
	protected String getALIASED_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "aliased";
	}
	
	/**
	 * terminal ALL_: "all" ;
	 */
	protected String getALL_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "all";
	}
	
	/**
	 * terminal AND_: "and" ;
	 */
	protected String getAND_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "and";
	}
	
	/**
	 * terminal ARRAY_: "array" ;
	 */
	protected String getARRAY_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "array";
	}
	
	/**
	 * terminal AT_: "at" ;
	 */
	protected String getAT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "at";
	}
	
	/**
	 * terminal BEGIN_: "begin" ;
	 */
	protected String getBEGIN_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "begin";
	}
	
	/**
	 * terminal BODY_: "body" ;
	 */
	protected String getBODY_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "body";
	}
	
	/**
	 * terminal BOIT : '<>';
	 */
	protected String getBOITToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "<>";
	}
	
	/**
	 * terminal BV : '|'|'!';
	 */
	protected String getBVToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "|";
	}
	
	/**
	 * terminal CASE_: "case" ;
	 */
	protected String getCASE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "case";
	}
	
	/**
	 * terminal CHD : '>>';
	 */
	protected String getCHDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ">>";
	}
	
	/**
	 * terminal CHG : '<<';
	 */
	protected String getCHGToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "<<";
	}
	
	/**
	 * terminal CONSTANT_: "constant" ;
	 */
	protected String getCONSTANT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "constant";
	}
	
	/**
	 * terminal DECLARE_: "declare" ;
	 */
	protected String getDECLARE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "declare";
	}
	
	/**
	 * terminal DELAY_: "delay" ;
	 */
	protected String getDELAY_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "delay";
	}
	
	/**
	 * terminal DELTA_: "delta" ;
	 */
	protected String getDELTA_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "delta";
	}
	
	/**
	 * terminal DIGITS_: "digits" ;
	 */
	protected String getDIGITS_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "digits";
	}
	
	/**
	 * terminal DO_: "do" ;
	 */
	protected String getDO_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "do";
	}
	
	/**
	 * terminal DP : ':';
	 */
	protected String getDPToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ":";
	}
	
	/**
	 * terminal DPE :':=';
	 */
	protected String getDPEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ":=";
	}
	
	/**
	 * terminal ELSE_: "else" ;
	 */
	protected String getELSE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "else";
	}
	
	/**
	 * terminal ELSIF_: "elsif" ;
	 */
	protected String getELSIF_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "elsif";
	}
	
	/**
	 * terminal END_: "end" ;
	 */
	protected String getEND_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "end";
	}
	
	/**
	 * terminal ENTRY_: "entry" ;
	 */
	protected String getENTRY_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "entry";
	}
	
	/**
	 * terminal ETOI2 : '**';
	 */
	protected String getETOI2Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "**";
	}
	
	/**
	 * terminal EXCEPTION_: "exception" ;
	 */
	protected String getEXCEPTION_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "exception";
	}
	
	/**
	 * terminal EXIT_: "exit" ;
	 */
	protected String getEXIT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "exit";
	}
	
	/**
	 * terminal FLECHE : '=>';
	 */
	protected String getFLECHEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "=>";
	}
	
	/**
	 * terminal FOR_: "for" ;
	 */
	protected String getFOR_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "for";
	}
	
	/**
	 * terminal FUNCTION_: "function" ;
	 */
	protected String getFUNCTION_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "function";
	}
	
	/**
	 * FormalDecimalFixedPointDefinition: DELTA_ BOIT DIGITS_ BOIT;
	 */
	protected String getFormalDecimalFixedPointDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "delta<>digits";
	}
	
	/**
	 * FormalDiscreteTypeDefinition: PG BOIT PD;
	 */
	protected String getFormalDiscreteTypeDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "(<>)";
	}
	
	/**
	 * FormalFloatingPointDefinition: DIGITS_ BOIT;
	 */
	protected String getFormalFloatingPointDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "digits<>";
	}
	
	/**
	 * FormalModularTypeDefinition: MOD_ BOIT;
	 */
	protected String getFormalModularTypeDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "mod<>";
	}
	
	/**
	 * FormalOrdinaryFixedPointDefinition: DELTA_ BOIT;
	 */
	protected String getFormalOrdinaryFixedPointDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "delta<>";
	}
	
	/**
	 * FormalSignedIntegerTypeDefinition: RANGE_ BOIT;
	 */
	protected String getFormalSignedIntegerTypeDefinitionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "range<>";
	}
	
	/**
	 * terminal GENERIC_: "generic" ;
	 */
	protected String getGENERIC_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "generic";
	}
	
	/**
	 * terminal GOTO_: "goto" ;
	 */
	protected String getGOTO_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "goto";
	}
	
	/**
	 * terminal IDENTIFIER: '^'
	 * 	     ;
	 */
	protected String getIDENTIFIERToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "^";
	}
	
	/**
	 * terminal IF_: "if" ;
	 */
	protected String getIF_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "if";
	}
	
	/**
	 * terminal INTERFACE_: "interface" ;
	 */
	protected String getINTERFACE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "interface";
	}
	
	/**
	 * terminal IN_: "in" ;
	 */
	protected String getIN_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "in";
	}
	
	/**
	 * terminal IS_: "is" ;
	 */
	protected String getIS_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "is";
	}
	
	/**
	 * terminal LIMITED_: "limited" ;
	 */
	protected String getLIMITED_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "limited";
	}
	
	/**
	 * terminal LOOP_: "loop" ;
	 */
	protected String getLOOP_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "loop";
	}
	
	/**
	 * terminal MOD_: "mod" ;
	 */
	protected String getMOD_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "mod";
	}
	
	/**
	 * terminal NEW_: "new" ;
	 */
	protected String getNEW_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "new";
	}
	
	/**
	 * terminal NOT_: "not" ;
	 */
	protected String getNOT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "not";
	}
	
	/**
	 * terminal NULL_: "null" ;
	 */
	protected String getNULL_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "null";
	}
	
	/**
	 * terminal OF_: "of" ;
	 */
	protected String getOF_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "of";
	}
	
	/**
	 * terminal OR_: "or" ;
	 */
	protected String getOR_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "or";
	}
	
	/**
	 * terminal OTHERS_: "others" ;
	 */
	protected String getOTHERS_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "others";
	}
	
	/**
	 * terminal OUT_: "out" ;
	 */
	protected String getOUT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "out";
	}
	
	/**
	 * terminal OVERRIDING_: "overriding" ;
	 */
	protected String getOVERRIDING_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "overriding";
	}
	
	/**
	 * terminal P : '.';
	 */
	protected String getPToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ".";
	}
	
	/**
	 * terminal PACKAGE_: "package" ;
	 */
	protected String getPACKAGE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "package";
	}
	
	/**
	 * terminal PD : ')';
	 */
	protected String getPDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ")";
	}
	
	/**
	 * terminal PG : '(';
	 */
	protected String getPGToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "(";
	}
	
	/**
	 * terminal PP : '..';
	 */
	protected String getPPToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "..";
	}
	
	/**
	 * terminal PRAGMA_: "pragma" ;
	 */
	protected String getPRAGMA_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "pragma";
	}
	
	/**
	 * terminal PRIVATE_: "private" ;
	 */
	protected String getPRIVATE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "private";
	}
	
	/**
	 * terminal PROCEDURE_: "procedure" ;
	 */
	protected String getPROCEDURE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "procedure";
	}
	
	/**
	 * terminal PROTECTED_: "protected" ;
	 */
	protected String getPROTECTED_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "protected";
	}
	
	/**
	 * terminal PV: ';';
	 */
	protected String getPVToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ";";
	}
	
	/**
	 * terminal QUOTE : "'";
	 */
	protected String getQUOTEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "\'";
	}
	
	/**
	 * terminal RAISE_: "raise" ;
	 */
	protected String getRAISE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "raise";
	}
	
	/**
	 * terminal RANGE_: "range" ;
	 */
	protected String getRANGE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "range";
	}
	
	/**
	 * terminal RECORD_: "record" ;
	 */
	protected String getRECORD_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "record";
	}
	
	/**
	 * terminal RENAMES_: "renames" ;
	 */
	protected String getRENAMES_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "renames";
	}
	
	/**
	 * terminal REQUEUE_: "requeue" ;
	 */
	protected String getREQUEUE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "requeue";
	}
	
	/**
	 * terminal RETURN_: "return" ;
	 */
	protected String getRETURN_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "return";
	}
	
	/**
	 * terminal REVERSE_: "reverse" ;
	 */
	protected String getREVERSE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "reverse";
	}
	
	/**
	 * terminal SELECT_: "select" ;
	 */
	protected String getSELECT_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "select";
	}
	
	/**
	 * terminal SEPARATE_: "separate" ;
	 */
	protected String getSEPARATE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "separate";
	}
	
	/**
	 * terminal SUBTYPE_: "subtype" ;
	 */
	protected String getSUBTYPE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "subtype";
	}
	
	/**
	 * terminal SYNCHRONIZED_: "synchronized" ;
	 */
	protected String getSYNCHRONIZED_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "synchronized";
	}
	
	/**
	 * terminal TAGGED_: "tagged" ;
	 */
	protected String getTAGGED_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "tagged";
	}
	
	/**
	 * terminal TASK_: "task" ;
	 */
	protected String getTASK_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "task";
	}
	
	/**
	 * terminal TERMINATE_: "terminate" ;
	 */
	protected String getTERMINATE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "terminate";
	}
	
	/**
	 * terminal THEN_: "then" ;
	 */
	protected String getTHEN_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "then";
	}
	
	/**
	 * terminal TYPE_: "type" ;
	 */
	protected String getTYPE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "type";
	}
	
	/**
	 * terminal USE_: "use" ;
	 */
	protected String getUSE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "use";
	}
	
	/**
	 * terminal V : ',';
	 */
	protected String getVToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ",";
	}
	
	/**
	 * terminal WHEN_: "when" ;
	 */
	protected String getWHEN_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "when";
	}
	
	/**
	 * terminal WHILE_: "while" ;
	 */
	protected String getWHILE_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "while";
	}
	
	/**
	 * terminal WITH_: "with" ;
	 */
	protected String getWITH_Token(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "with";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_AttributeDesignator_ACCESS_TerminalRuleCall_1_1_or_DELTA_TerminalRuleCall_1_2_or_DIGITS_TerminalRuleCall_1_3_or_IDENTIFIERTerminalRuleCall_1_0_0.equals(syntax))
				emit_AttributeDesignator_ACCESS_TerminalRuleCall_1_1_or_DELTA_TerminalRuleCall_1_2_or_DIGITS_TerminalRuleCall_1_3_or_IDENTIFIERTerminalRuleCall_1_0_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_BlockStatement_DECLARE_TerminalRuleCall_1_0_q.equals(syntax))
				emit_BlockStatement_DECLARE_TerminalRuleCall_1_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_BlockStatement_IDENTIFIERTerminalRuleCall_5_q.equals(syntax))
				emit_BlockStatement_IDENTIFIERTerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ExtendedReturnStatement_ALIASED_TerminalRuleCall_3_q.equals(syntax))
				emit_ExtendedReturnStatement_ALIASED_TerminalRuleCall_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_FormalDerivedTypeDefinition___WITH_TerminalRuleCall_4_1_PRIVATE_TerminalRuleCall_4_2__q.equals(syntax))
				emit_FormalDerivedTypeDefinition___WITH_TerminalRuleCall_4_1_PRIVATE_TerminalRuleCall_4_2__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_FormalPackageActualPart___OTHERS_TerminalRuleCall_1_0_1_0_FLECHETerminalRuleCall_1_0_1_1__q.equals(syntax))
				emit_FormalPackageActualPart___OTHERS_TerminalRuleCall_1_0_1_0_FLECHETerminalRuleCall_1_0_1_1__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_FormalPackageActualPart___VTerminalRuleCall_1_2_3_0_OTHERS_TerminalRuleCall_1_2_3_1_FLECHETerminalRuleCall_1_2_3_2_BOITTerminalRuleCall_1_2_3_3__q.equals(syntax))
				emit_FormalPackageActualPart___VTerminalRuleCall_1_2_3_0_OTHERS_TerminalRuleCall_1_2_3_1_FLECHETerminalRuleCall_1_2_3_2_BOITTerminalRuleCall_1_2_3_3__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_FormalTypeDefinition_FormalDecimalFixedPointDefinitionParserRuleCall_7_1_or_FormalDiscreteTypeDefinitionParserRuleCall_2_1_or_FormalFloatingPointDefinitionParserRuleCall_5_1_or_FormalModularTypeDefinitionParserRuleCall_4_1_or_FormalOrdinaryFixedPointDefinitionParserRuleCall_6_1_or_FormalSignedIntegerTypeDefinitionParserRuleCall_3_1.equals(syntax))
				emit_FormalTypeDefinition_FormalDecimalFixedPointDefinitionParserRuleCall_7_1_or_FormalDiscreteTypeDefinitionParserRuleCall_2_1_or_FormalFloatingPointDefinitionParserRuleCall_5_1_or_FormalModularTypeDefinitionParserRuleCall_4_1_or_FormalOrdinaryFixedPointDefinitionParserRuleCall_6_1_or_FormalSignedIntegerTypeDefinitionParserRuleCall_3_1(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_LoopParameterSpecification_REVERSE_TerminalRuleCall_2_q.equals(syntax))
				emit_LoopParameterSpecification_REVERSE_TerminalRuleCall_2_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PackageSpecification_PRIVATE_TerminalRuleCall_2_0_q.equals(syntax))
				emit_PackageSpecification_PRIVATE_TerminalRuleCall_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ProtectedDefinition_IDENTIFIERTerminalRuleCall_4_q.equals(syntax))
				emit_ProtectedDefinition_IDENTIFIERTerminalRuleCall_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ProtectedDefinition_PRIVATE_TerminalRuleCall_2_0_q.equals(syntax))
				emit_ProtectedDefinition_PRIVATE_TerminalRuleCall_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_SubprogramDefault_BOITTerminalRuleCall_1_1_or_NULL_TerminalRuleCall_1_2.equals(syntax))
				emit_SubprogramDefault_BOITTerminalRuleCall_1_1_or_NULL_TerminalRuleCall_1_2(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_TaskDefinition_PRIVATE_TerminalRuleCall_2_0_q.equals(syntax))
				emit_TaskDefinition_PRIVATE_TerminalRuleCall_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * Ambiguous syntax:
	 *     IDENTIFIER | ACCESS_ | DELTA_ | DIGITS_
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) (rule start)
	 */
	protected void emit_AttributeDesignator_ACCESS_TerminalRuleCall_1_1_or_DELTA_TerminalRuleCall_1_2_or_DIGITS_TerminalRuleCall_1_3_or_IDENTIFIERTerminalRuleCall_1_0_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     DECLARE_?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) BEGIN_ handledSequenceOfStatements=HandledSequenceOfStatements
	 *     blockStatementIdentifier=IDENTIFIER DP (ambiguity) BEGIN_ handledSequenceOfStatements=HandledSequenceOfStatements
	 */
	protected void emit_BlockStatement_DECLARE_TerminalRuleCall_1_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     IDENTIFIER?
	 *
	 * This ambiguous syntax occurs at:
	 *     handledSequenceOfStatements=HandledSequenceOfStatements END_ (ambiguity) (rule end)
	 */
	protected void emit_BlockStatement_IDENTIFIERTerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ALIASED_?
	 *
	 * This ambiguous syntax occurs at:
	 *     identifier=IDENTIFIER DP (ambiguity) returnSubtype=ReturnSubtypeIndication
	 */
	protected void emit_ExtendedReturnStatement_ALIASED_TerminalRuleCall_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (WITH_ PRIVATE_)?
	 *
	 * This ambiguous syntax occurs at:
	 *     subtypeMark=Name (ambiguity) (rule end)
	 */
	protected void emit_FormalDerivedTypeDefinition___WITH_TerminalRuleCall_4_1_PRIVATE_TerminalRuleCall_4_2__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (OTHERS_ FLECHE)?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) PG (ambiguity) box?=BOIT
	 */
	protected void emit_FormalPackageActualPart___OTHERS_TerminalRuleCall_1_0_1_0_FLECHETerminalRuleCall_1_0_1_1__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (V OTHERS_ FLECHE BOIT)?
	 *
	 * This ambiguous syntax occurs at:
	 *     formalPackageAssociation+=FormalPackageAssociation (ambiguity) PD (rule end)
	 */
	protected void emit_FormalPackageActualPart___VTerminalRuleCall_1_2_3_0_OTHERS_TerminalRuleCall_1_2_3_1_FLECHETerminalRuleCall_1_2_3_2_BOITTerminalRuleCall_1_2_3_3__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (
	  *         FormalDiscreteTypeDefinition | 
	  *         FormalSignedIntegerTypeDefinition | 
	  *         FormalModularTypeDefinition | 
	  *         FormalFloatingPointDefinition | 
	  *         FormalOrdinaryFixedPointDefinition | 
	  *         FormalDecimalFixedPointDefinition
	  *     )
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) (rule start)
	 */
	protected void emit_FormalTypeDefinition_FormalDecimalFixedPointDefinitionParserRuleCall_7_1_or_FormalDiscreteTypeDefinitionParserRuleCall_2_1_or_FormalFloatingPointDefinitionParserRuleCall_5_1_or_FormalModularTypeDefinitionParserRuleCall_4_1_or_FormalOrdinaryFixedPointDefinitionParserRuleCall_6_1_or_FormalSignedIntegerTypeDefinitionParserRuleCall_3_1(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     REVERSE_?
	 *
	 * This ambiguous syntax occurs at:
	 *     identifier=IDENTIFIER IN_ (ambiguity) discreteSubtypeDefinition=DiscreteSubtypeDefinition
	 */
	protected void emit_LoopParameterSpecification_REVERSE_TerminalRuleCall_2_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     PRIVATE_?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) END_ (rule start)
	 *     (rule start) (ambiguity) END_ endname=PATHIDENTIFIER
	 *     publicBasicDeclarativeItems+=BasicDeclarativeItem PV (ambiguity) END_ (rule end)
	 *     publicBasicDeclarativeItems+=BasicDeclarativeItem PV (ambiguity) END_ endname=PATHIDENTIFIER
	 */
	protected void emit_PackageSpecification_PRIVATE_TerminalRuleCall_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     IDENTIFIER?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) PRIVATE_? END_ (ambiguity) (rule start)
	 *     protectedOperationDeclaration+=ProtectedElementDeclaration END_ (ambiguity) (rule end)
	 *     protectedOperationDeclaration+=ProtectedOperationDeclaration PRIVATE_? END_ (ambiguity) (rule end)
	 */
	protected void emit_ProtectedDefinition_IDENTIFIERTerminalRuleCall_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     PRIVATE_?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) END_ IDENTIFIER? (rule start)
	 *     protectedOperationDeclaration+=ProtectedOperationDeclaration (ambiguity) END_ IDENTIFIER? (rule end)
	 */
	protected void emit_ProtectedDefinition_PRIVATE_TerminalRuleCall_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     BOIT | NULL_
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) (rule start)
	 */
	protected void emit_SubprogramDefault_BOITTerminalRuleCall_1_1_or_NULL_TerminalRuleCall_1_2(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     PRIVATE_?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) (rule start)
	 *     taskItems+=TaskItem PV (ambiguity) (rule end)
	 */
	protected void emit_TaskDefinition_PRIVATE_TerminalRuleCall_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
