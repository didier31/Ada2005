grammar org.xtext.ada2005.Adb hidden(SL_COMMENT, WS)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate adb "http://www.xtext.org/ada2005/adb"

Compilation: (compilationUnits += CompilationUnit)*;

CompilationUnit:
	contextClause=ContextClause unit = Unit PV (=> pragmas+=Pragma PV)* 
;

Unit: => SubprogramBody
    | => LibraryUnitDeclaration // TODO: Cutting Subunit, Package_body alternative for ads
    | PackageBody    	
    | SeparateSubunit               // TODO: Cutting Library_unit_declaration for adb
    ;


// Context clause
ContextClause: {ContextClause}
	(contextItems+=ContextItem PV)*
;

ContextItem:
	  WithClause
	| UseClause
	| Pragma
;

WithClause: 
	(limited?=LIMITED_)? (private?=PRIVATE_)? WITH_ importURI+=[LibraryUnitDeclaration | PATHIDENTIFIER] (V importURI+=[LibraryUnitDeclaration | PATHIDENTIFIER])*
    ; // TODO: check if Name should be Defining_program_unit_name, because
      // it seems XXX.XXX.XXX.XXX is the sole notation possible 


UseClause:
	  UsePackageClause
	| UseTypeClause
    ;

UsePackageClause:
	USE_ importedNamespace+=[LibraryUnitDeclaration | PATHIDENTIFIER] (V importedNamespace+=[LibraryUnitDeclaration | PATHIDENTIFIER])*
    ; // TODO: check if Name should be Defining_program_unit_name, because
      // it seems XXX.XXX.XXX.XXX is the sole notation possible
      // TODO: check importedNamespace refers to LibraryUnitDeclaration's names.

UseTypeClause:
     USE_ TYPE_ typesNames+=PATHIDENTIFIER (V useTypeRefs+=PATHIDENTIFIER)*
    ; // TODO: check if Name should be Defining_program_unit_name (or something adapted), because
      // it seems XXX.XXX.XXX.XXX is the sole notation possible

LibraryUnitDeclaration:
	(private?=PRIVATE_)?
    libraryUnitSpecification=LibraryUnitSpecification
; 

LibraryUnitSpecification:
	     PackageDeclaration
	|    GenericInstantiation
	|    SubprogramSpecification     	
	|    GenericDeclaration  
;

PackageDeclaration: 
     PackageDefinition | Renaming;

PackageDefinition: PACKAGE_ name=PATHIDENTIFIER IS_ packageSpecification=PackageSpecification;

Renaming: PACKAGE_ name=PATHIDENTIFIER RENAMES_ renamed = PATHIDENTIFIER;



GenericDeclaration: 
      GENERIC_
           genericItems = GenericItems
      	   librarySpecification = LibrarySpecification
      ;

GenericInstantiation: 
           (PACKAGE_ name=PATHIDENTIFIER IS_ NEW_ genericName = PATHIDENTIFIER                                 
         | overriding=OverridingIndicator? PROCEDURE_ name=PATHIDENTIFIER IS_ NEW_ genericName = PATHIDENTIFIER
         | overriding=OverridingIndicator? FUNCTION_ name=PATHNAME IS_ NEW_ genericName = PATHNAME) genericActualPart = GenericActualPart? // NOTE: Changed genericName = Name by Simple_name  
        	                                                      // TODO : semantic check: 
                                                                  // if actual parameter Expression = Name, check it is either a :
                                                                  //        | Variable_name
                                                                  //        | Subprogram_name
                                                                  //        | Entry_name
                                                                  //        | Subtype_mark
                                                                  //        | Package_instance_name 
        ; 
        
PackageSpecification: {PackageSpecification}
    (publicBasicDeclarativeItems+=BasicDeclarativeItem PV)* 
    (PRIVATE_ 
    (privateBasicDeclarativeItems+=BasicDeclarativeItem PV)*
    )? 
    END_ endname=PATHIDENTIFIER? // TODO (by the initial author) validate same as Name 
;

SubprogramBody: 
        subprogramSpecification=SubprogramSpecification IS_ 
        (declarativeItems += DeclarativeItem PV)* 
        BEGIN_
        handledSequenceOfStatements=HandledSequenceOfStatements
        END_ endname=PATHNAME?
        ;

// NB: Added just for meta-model handling (not for syntax)
DeclarativeBlock:
	  SubprogramBody
	| PackageBody
	| EntryBody
	| TaskBody
	| BlockStatement
;            

BasicDeclarativeItem:
	  BasicDeclaration
	| AspectClause
	| UseClause
	| Pragma
;

BasicDeclaration:
         GenericDeclaration
    | => ObjectDeclaration
	| => SubprogramDeclaration
	| => PackageDeclaration
	| => NumberDeclaration
	| => ExceptionDeclaration
	|    GenericInstantiation
	|    TaskDeclaration
	|    TypeDeclaration
;

TaskDeclaration:
	  TASK_ (TYPE_ name=IDENTIFIER knownDiscriminantPart=KnownDiscriminantPart? | name=IDENTIFIER) (IS_ (NEW_ interfaceList=InterfaceList WITH_)?
        taskDefinition=TaskDefinition END_ endid=[TaskDeclaration|IDENTIFIER]?)?
;

TypeDeclaration: NewTypeDeclaration | SubtypeDeclaration;

NewTypeDeclaration:
	  => FullTypeDeclaration
	| => IncompleteTypeDeclaration
	|    PrivateTypeDeclaration      // TODO: Check it is in a public section of package only.
	| => PrivateExtensionDeclaration // TODO: Check it is in a public section of package only.
;

FullTypeDeclaration:
	  FullDataTypeDeclaration
	| ProtectedTypeDeclaration
	;

FullDataTypeDeclaration: 
	TYPE_ name=IDENTIFIER knownDiscriminantPart=KnownDiscriminantPart? IS_ typeDefinition=TypeDefinition
;

IncompleteTypeDeclaration: 
        TYPE_ name=IDENTIFIER discriminantPart=DiscriminantPart? (tagged?=IS_ TAGGED_)?
        ;   

PrivateTypeDeclaration:
	  TYPE_ name=IDENTIFIER discriminantPart=DiscriminantPart? IS_
            ((abstract?=ABSTRACT_)? tagged?=TAGGED_)? (limited?=LIMITED_)? PRIVATE_
	;

PrivateExtensionDeclaration:
		  TYPE_ name=IDENTIFIER discriminantPart=DiscriminantPart? IS_
               abstract?=ABSTRACT_? (limited?=LIMITED_ | synchronized?=SYNCHRONIZED_)? 
               NEW_ ancestorSubtypeIndication=SubtypeIndication (AND_ interfaceList=InterfaceList)? WITH_ PRIVATE_
;

TaskItem: 
          EntryDeclaration
        | AspectClause
        ;

EntryDeclaration: 
        overriding=OverridingIndicator? ENTRY_ name=IDENTIFIER (PG discreteSubtypeDefinition=DiscreteSubtypeDefinition PD)? formalPart=FormalPart?
        ;

OverridingIndicator: {OverridingIndicator}
        (not?=NOT_)? OVERRIDING_
    ;	

ProtectedTypeDeclaration: 
        PROTECTED_ TYPE_ name=IDENTIFIER knownDiscriminantPart = KnownDiscriminantPart? IS_ 
         (NEW_ interfaceList=InterfaceList WITH_)? protectedDefinition=ProtectedDefinition
        ;

ProtectedDefinition: {ProtectedDefinition}
        protectedOperationDeclaration += ProtectedOperationDeclaration* 
        (PRIVATE_ protectedOperationDeclaration += ProtectedElementDeclaration*)? 
        END_ IDENTIFIER?
        ;        

ProtectedElementDeclaration: 
          ProtectedOperationDeclaration
        | ComponentDeclaration
        ;

ProtectedOperationDeclaration: 
          SubprogramDeclaration
        | EntryDeclaration
        | AspectClause
        ;

SubprogramDeclaration: 
    subprogramSpecification=SubprogramSpecification 
    (IS_ abstract?=ABSTRACT_ 
   | RENAMES_ renamedName=PATHNAME 
   //| (IS_ body=Subprogram_body)                 // TODO: Check if it is part of the syntax. I think no because it is redundant with an other rule and abusively included in Library_unit_declaration derivations.  
   | IS_ null?=NULL_)? // TODO: Check that "is null" is applied on a procedure only. 
    ;

SubprogramSpecification: ProcedureSpecification
	                   | FunctionSpecification 
                       ;
	
ProcedureSpecification: overridingIndicator=OverridingIndicator? PROCEDURE_ name=IDENTIFIER formalPart=FormalPart?;

FunctionSpecification: overridingIndicator=OverridingIndicator? FUNCTION_ name=DIRECT_NAME parameterAndResultProfile=ParameterAndResultProfile;   

HandledSequenceOfStatements:
        SequenceOfStatements (EXCEPTION_ exceptionHandler += ExceptionHandler+)?
        ;

ExceptionChoice: 
      name=Name
    | others?=OTHERS_
    ;
        
ExceptionHandler:
    WHEN_ (name=IDENTIFIER DP)? exceptionChoice += ExceptionChoice (BV exceptionChoice += ExceptionChoice)* FLECHE sequenceOfStatements = SequenceOfStatements
    ;              

DeclarativeItem:
	   => Body
     | => BasicDeclarativeItem
     ;

Body:
     => ProperBody
   |    BodyStub
        ;          

ProperBody:
          SubprogramBody
        | PackageBody
        | TaskBody
        | ProtectedBody
        ;

Label:
        CHG identifier=IDENTIFIER CHD
        ;
        
SequenceOfStatements:
        (statements += LabelisableStatement PV)+
        ;

LabelisableStatement:
	      labels += Label*
          statement=Statement
      ;

Statement:  SimpleStatement 
         | CompoundStatement 
         | Pragma;

SimpleStatement: 
         GotoStatement
       | => AssignmentStatement
       | SimpleReturnStatement
       | RequeueStatement
       | NullStatement
       | AbortStatement
//       | Code_statement // TODO: to remove code
       | ExitStatement
       | => ProcedureOrEntryCallStatement // TODO: Semantic rule : check that it could be a pure qualified expression. Then, it is a code_statement  
       | DelayStatement
       | RaiseStatement
       ;

CompoundStatement:
         IfStatement
       | LoopStatement
       | ExtendedReturnStatement
       | AcceptStatement
       | CaseStatement
       | BlockStatement
       | SelectStatement
       ;

NullStatement:
        null?=NULL_
        ;          

LibrarySpecification: 
	              SubprogramSpecification // TODO: Check name is always Qualified_identifier even for functions.
               |  PackageDefinition;

GenericItems: {GenericItems}
	(genericItems+=GenericItem PV)*
;

GenericItem: GenericFormalParameterDeclaration | UseClause;

GenericFormalParameterDeclaration:
          FormalObjectDeclaration
        | FormalTypeDeclaration
        | FormalSubprogramDeclaration
        | FormalPackageDeclaration
        ;
        
FormalObjectDeclaration:
          idList=DefiningIdentifierList DP mode=Mode ( optNullExclusion=OptNullExclusion subtypeMark=Name 
                                                     | anonymousAccessDefinition=AnonymousAccessDefinition) 
                                         (DPE defaultExpression = Expression)?
        ;

FormalTypeDeclaration:
        TYPE_ identifier=IDENTIFIER discriminantPart=DiscriminantPart? IS_ formalTypeDefinition=FormalTypeDefinition
        ;

FormalTypeDefinition: 
        FormalPrivateTypeDefinition
      | FormalDerivedTypeDefinition
      | {FormalTypeDefinition} FormalDiscreteTypeDefinition
      | {FormalTypeDefinition} FormalSignedIntegerTypeDefinition
      | {FormalTypeDefinition} FormalModularTypeDefinition
      | {FormalTypeDefinition} FormalFloatingPointDefinition
      | {FormalTypeDefinition} FormalOrdinaryFixedPointDefinition
      | {FormalTypeDefinition} FormalDecimalFixedPointDefinition
      | ArrayTypeDefinition
      | AccessTypeDefinition
      | InterfaceTypeDefinition
      ;

FormalDiscreteTypeDefinition: PG BOIT PD;

FormalSignedIntegerTypeDefinition: RANGE_ BOIT;

FormalModularTypeDefinition: MOD_ BOIT;

FormalFloatingPointDefinition: DIGITS_ BOIT;

FormalOrdinaryFixedPointDefinition: DELTA_ BOIT;

FormalDecimalFixedPointDefinition: DELTA_ BOIT DIGITS_ BOIT;


FormalPrivateTypeDefinition: {FormalPrivateTypeDefinition}
      (abstract?=ABSTRACT_? tagged?=TAGGED_)? limited?=LIMITED_? PRIVATE_
    ;

FormalDerivedTypeDefinition:
      absract=ABSTRACT_? (limited?=LIMITED_ | synchronized?=SYNCHRONIZED_)? NEW_ subtypeMark=Name ((AND_ interfaceList=InterfaceList)? WITH_ PRIVATE_)?
    ;
        
FormalSubprogramDeclaration:
      WITH_ subprogramSpecification=SubprogramSpecification ((IS_ abstract=ABSTRACT_? subprogramDefault=SubprogramDefault)?)
    ;
        
SubprogramDefault: {SubprogramDefault}
    ( defaultName=PATHNAME // TODO: To be confirmed it is not a Name as specified by the RM.
    | BOIT
    | NULL_
    )
    ;

FormalPackageDeclaration:
      WITH_ PACKAGE_ name=IDENTIFIER IS_ NEW_ genericPackageName=PATHIDENTIFIER formalPackageActualPart = FormalPackageActualPart
      ;
        
FormalPackageActualPart: {FormalPackageActualPart}
      ( => PG (OTHERS_ FLECHE)? box ?= BOIT PD
      | => genericActualPart = GenericActualPart?
      | => PG formalPackageAssociation += FormalPackageAssociation (V formalPackageAssociation += FormalPackageAssociation)* (V OTHERS_ FLECHE BOIT)? PD
      )
      ;
        
FormalPackageAssociation: 
      (genericAssociation = GenericAssociation
    | genericFormalParameterSelectorName=SelectorName DPE BOIT)
    ;

ExceptionDeclaration:
        idList=DefiningIdentifierList DP EXCEPTION_ (RENAMES_ renamedName=Name)?
        ;

ObjectDeclaration:
	  DataInstanceDeclaration
	| SingleProtectedDeclaration
    ;
DataInstanceDeclaration: 
      definingIdentifierList = DefiningIdentifierList DP (aliased?=ALIASED_)? (constant?=CONSTANT_)? 
	                           (  subtypeIndication=SubtypeIndication (DPE expression=Expression | RENAMES_ objectName=Name)?
	                            | anonymousAccessDefinition=AnonymousAccessDefinition (DPE expression=Expression | RENAMES_ objectName=Name)?
	                            | arrayTypeDefinition=ArrayTypeDefinition (DPE expression=Expression)?)
	                            
	; // TODO: for RENAMES alternatives, check Defining_identifier_list's size = 1 and Subtype_indication has no constraint.

SingleProtectedDeclaration: 
        PROTECTED_ name=IDENTIFIER IS_ (NEW_ interfaceList=InterfaceList WITH_)? protectedDefinition=ProtectedDefinition
        ;

Pragma:
      PRAGMA_ name=IDENTIFIER (PG pragmaArgumentAssociation += PragmaArgumentAssociation (V pragmaArgumentAssociation += PragmaArgumentAssociation)* PD)?
    ;

PragmaArgumentAssociation: 
	  (name=IDENTIFIER FLECHE)? effectiveArgument=Expression
    ;
        
SubtypeDeclaration:
      SUBTYPE_ name=IDENTIFIER IS_ subtypeIndication=SubtypeIndication
    ;
        
NumberDeclaration:
      idList=DefiningIdentifierList DP CONSTANT_ DPE staticExpression = Expression
    ;

AssignmentStatement:
        variableName=Name DPE initialValue = Expression
        ;

IfStatement:
        IF_ ifCondition = Expression THEN_ 
            thenStatements=SequenceOfStatements 
        (ELSIF_ elsifConditions += Expression THEN_ 
        	elsifStatements += SequenceOfStatements
        )* 
        (ELSE_ elseStatements = SequenceOfStatements)? 
        END_ IF_
        ;

CaseStatement:
        CASE_ caseValue=Expression IS_ 
               (caseStatementAlternatives += CaseStatementAlternative)+
        END_ CASE_
        ;

CaseStatementAlternative:
        WHEN_ discreteChoiceList=DiscreteChoiceList FLECHE sequenceOfStatements = SequenceOfStatements
        ;

LoopStatement: 
        (name=IDENTIFIER DP)? iterationScheme = IterationScheme? 
        LOOP_ 
        sequenceOfStatements=SequenceOfStatements 
        END_ LOOP_ sameName=IDENTIFIER?
        ;

IterationScheme:
          WHILE_ condition=Expression
        | FOR_ iterationSpecification=LoopParameterSpecification
        ;

LoopParameterSpecification:
        identifier=IDENTIFIER IN_ REVERSE_? discreteSubtypeDefinition=DiscreteSubtypeDefinition
        ;

BlockStatement: 
        (blockStatementIdentifier=IDENTIFIER DP)? 
        (DECLARE_ (declarativeItems += DeclarativeItem PV)*)? 
        BEGIN_ 
        handledSequenceOfStatements=HandledSequenceOfStatements 
        END_ IDENTIFIER?
        ;

ExitStatement: {ExitStatement}
        EXIT_ (name=[LoopStatement | IDENTIFIER])? (WHEN_ condition=Expression)?
        ;
GotoStatement:
        GOTO_ labelId=IDENTIFIER
        ;

ProcedureOrEntryCallStatement:
          callee=Name 
        ;  

SimpleReturnStatement: {SimpleReturnStatement}
        RETURN_ returnValue=Expression?
        ;

ExtendedReturnStatement:
        RETURN_ identifier=IDENTIFIER DP ALIASED_? returnSubtype=ReturnSubtypeIndication 
                (DPE expression = Expression)? 
                (DO_ handledSequenceOfStatements = HandledSequenceOfStatements 
                 END_ RETURN_
                )?
        ;

ReturnSubtypeIndication:
          SubtypeIndication
        | AnonymousAccessDefinition
        ;

PackageBody:
        PACKAGE_ BODY_ name=[PackageDeclaration | PATHIDENTIFIER] IS_ 
        (declarativeItems += DeclarativeItem PV)*
        (BEGIN_ 
        	handledSequenceOfStatements=HandledSequenceOfStatements
        )? END_ endName=[PackageDeclaration | PATHIDENTIFIER]? // TODO: Check endName=name
        ; 

TaskDefinition: {TaskDefinition}
        (taskItems += TaskItem PV)* (PRIVATE_ (taskItems += TaskItem PV)*)? 
        ;

TaskBody:
        TASK_ BODY_ name=[TaskDeclaration|IDENTIFIER] IS_
        (declarativeItems += DeclarativeItem PV)*
        BEGIN_
        handledSequenceOfStatements=HandledSequenceOfStatements
        END_ endId=[TaskDeclaration|IDENTIFIER]?
        ;

ProtectedBody: 
        PROTECTED_ BODY_ identifier=IDENTIFIER IS_ protectedOperationItem += ProtectedOperationItem* END_ idTask=IDENTIFIER?
        ;

ProtectedOperationItem:
        SubprogramDeclaration
     | => SubprogramBody
     | EntryBody
     | AspectClause
     ;

AcceptStatement:
        ACCEPT_ entryName=[EntryDeclaration | IDENTIFIER] (PG entryIndex = EntryIndex PD)? formalPart=FormalPart? 
        (DO_ 
        	handledSequenceOfStatements=HandledSequenceOfStatements END_ entryidentifier=IDENTIFIER?
        )?
        ; 

EntryIndex:
        Expression
        ;

EntryBody:
         ENTRY_ name=[EntryDeclaration | IDENTIFIER] entryBodyFormalPart=EntryBodyFormalPart entryBarrier = EntryBarrier IS_ 
         (declarativeItems += DeclarativeItem PV)*
         BEGIN_
         handledSequenceOfStatements=HandledSequenceOfStatements
         END_ endid=IDENTIFIER?
         ;

EntryBodyFormalPart: {EntryBodyFormalPart}
        (PG entryIndexSpecification=EntryIndexSpecification PD)? formalPart=FormalPart?
        ;

EntryBarrier:
        WHEN_ condition=Expression
        ;

EntryIndexSpecification:
        FOR_ name=IDENTIFIER IN_ discreteSubtypeDefinition=DiscreteSubtypeDefinition
        ;

RequeueStatement:
        REQUEUE_ name=Name (abort?=WITH_ ABORT_)?
        ;

DelayStatement:
        DELAY_ until=UNTIL_? delay=Expression
        ;

SelectStatement:
	      => SelectiveAccept
        | => TimedEntryCall
        | => ConditionalEntryCall
        | => AsynchronousSelect
        ;

SelectiveAccept:
         SELECT_ selectguard=Guard? 
         selectAlternative = SelectAlternative PV
         (guardedAlternatives += GuardedAlternative PV)* 
         (ELSE_ elseStatements=SequenceOfStatements)? 
         END_ SELECT_
        ;
        
GuardedAlternative: OR_ guard=Guard? alternative = SelectAlternative;        

Guard:
        WHEN_ condition=Expression FLECHE
        ;

SelectAlternative: 
          AcceptAlternative
        | DelayAlternative
        | {SelectAlternative} TERMINATE_
        ;

AcceptAlternative:
        acceptStatement=AcceptStatement (PV sequenceOfStatements = SequenceOfStatements)?
        ;

DelayAlternative:
        delayStatement=DelayStatement (PV sequenceOfStatements = SequenceOfStatements)?
        ;

TimedEntryCall:
        SELECT_ entryCallAlternative=EntryCallAlternative PV OR_ delayAlternative=DelayAlternative PV END_ SELECT_
        ;

EntryCallAlternative:
        call=ProcedureOrEntryCallStatement (PV sequenceOfStatements = SequenceOfStatements)?
        ;

ConditionalEntryCall:
        SELECT_ entryCallAlternative=EntryCallAlternative 
        ELSE_ elseSequenceOfStatements=SequenceOfStatements 
        END_ SELECT_
        ;

AsynchronousSelect:
        SELECT_ triggeringAlternative=TriggeringAlternative PV
        THEN_ ABORT_ abortablePart=AbortablePart 
        END_ SELECT_
        ;

TriggeringAlternative:
        triggeringStatement=TriggeringStatement (PV sequenceOfStatements = SequenceOfStatements)?
        ;

TriggeringStatement:
         ProcedureOrEntryCallStatement
       | DelayStatement
        ;

AbortablePart:
        SequenceOfStatements
        ;

AbortStatement:
        ABORT_ TaskNames
        ;

TaskNames: taskNames+=Name (V taskNames+=Name)*;

BodyStub: 
      (  SubprogramSpecification
       | PackageBodyStub
       | TaskBodyStub
       | ProtectedBodyStub 
      ) IS_ SEPARATE_
       ;

PackageBodyStub:
        PACKAGE_ BODY_ name=IDENTIFIER
        ;

TaskBodyStub:
        TASK_ BODY_ name=IDENTIFIER
        ;

ProtectedBodyStub:
        PROTECTED_ BODY_ name=IDENTIFIER
        ;
        
SeparateSubunit:
        SEPARATE_ PG parentUnitName = PATHIDENTIFIER PD properBody = ProperBody
        ;
        
RaiseStatement: {RaiseStatement}
	   // TODO: semantic rule : Check that Expression is of type String
       RAISE_ (exceptionName=Name (WITH_ withExpression=Expression)?)?
       ;
        
GenericActualPart:
         PG genericAssociation += GenericAssociation (V genericAssociation += GenericAssociation)* PD
         ;

GenericAssociation:
         (selectorName=SelectorName FLECHE)? expplicitGenericActualParam=ExplicitGenericActualParameter
         ;

ExplicitGenericActualParameter:
                Expression // TODO : semantic check: 
                           // if crossref is Expression = Name, check it is
                           //        | Variable_name
                           //        | Subprogram_name
                           //        | Entry_name
                           //        | Subtype_mark
                           //        | Package_instance_name
        ;

//Code_statement: // TODO: To be removed
//        qualifiedExpression=Qualified_expression PV
//        ;

///////////////////////////////////////////////////////////////////////////////
//
//                       Grammar module : TYPES.XTEXT 
//
///////////////////////////////////////////////////////////////////////////////

TypeDefinition:
	  EnumerationTypeDefinition
	| RealTypeDefinition
	| RecordTypeDefinition
	| DerivedTypeDefinition
	| IntegerTypeDefinition
	| ArrayTypeDefinition
	| AccessTypeDefinition
	| InterfaceTypeDefinition
	;

DiscriminantPart: 
      UnknownDiscriminantPart
    | KnownDiscriminantPart
    ;

UnknownDiscriminantPart: PG box?=BOIT PD;

KnownDiscriminantPart:
        PG discriminantsSpecification += DiscriminantSpecification (PV discriminantsSpecification += DiscriminantSpecification)* PD
        ;

DiscriminantSpecification:
        definingIdentifiers=DefiningIdentifierList DP optNullExclusion=OptNullExclusion (accessDefinition = NotNullAccessDefinition | subtypeMark=Name) (DPE defaultValue = Expression)?
        ;

InterfaceList: 
        interfaceSubtypeMark += Name (AND_ interfaceSubtypeMark += Name)*
        ;

InterfaceTypeDefinition: {InterfaceTypeDefinition}
        (limited?=LIMITED_ | task?=TASK_ | protected?=PROTECTED_ | synchro?=SYNCHRONIZED_)? INTERFACE_ (AND_ interfaceList=InterfaceList)?
        ;

DerivedTypeDefinition:
      abstract=ABSTRACT_? limited=LIMITED_? NEW_ subtypeIndication=SubtypeIndication ((AND_ interfaceList = InterfaceList)? recordExtentionPart = RecordExtensionPart)?
    ;

RecordExtensionPart:
        WITH_ recordDefinition=RecordDefinition
        ;

AccessTypeDefinition:
	  optNullExclusion=OptNullExclusion accessDefinition=AccessSpecification
    ;

AccessSpecification: AccessToDataDefinition
	               | AccessToSubprogramDefinition;

AccessToSubprogramDefinition: {AccessToSubprogramDefinition}
      ACCESS_ (protected?=PROTECTED_)? 
                (PROCEDURE_ formalPart=FormalPart?
                | FUNCTION_ parameterAndResultProfile=ParameterAndResultProfile)
	;

AccessToDataDefinition:
      ACCESS_ (generalAccessModifier=GeneralAccessModifier)? subtypeIndication=SubtypeIndication
      ;

GeneralAccessModifier:
	  ALL_
	| CONSTANT_
	;
	
ArrayTypeDefinition:
    ARRAY_ 
    PG arrayIndexes=ArrayIndexes PD OF_ componentDefinition=ComponentDefinition
    ;

ArrayIndexes:
     => UnconstrainedIndexes
    |   ConstrainedIndexes
;

UnconstrainedIndexes: subtypeMark+=Name RANGE_ BOIT (V subtypeMark+=Name RANGE_ BOIT)*
;

ConstrainedIndexes: constrainedIndex+=DiscreteSubtypeDefinition (V constrainedIndex+=DiscreteSubtypeDefinition)*
;

DiscreteSubtypeDefinition:
   => DiscreteRange 
    | SubtypeIndication // TODO: Semantic rule: check Subtype_indication is discrete. 
    ;

ComponentDefinition:
	  (aliased?=ALIASED_)? (subtypeIndication=SubtypeIndication
	                      | anonymousAccessDefinition=AnonymousAccessDefinition)
	;

AnonymousAccessDefinition:
        optNullExclusion=OptNullExclusion accessDef=NotNullAccessDefinition
        ;

NotNullAccessDefinition: 
	ACCESS_ (AccessToDataInstance 
		   | AccessToSubprogramDefinition)
;

AccessToDataInstance : constant=CONSTANT_? name=Name;

ParameterAndResultProfile:
      (formalPart=FormalPart)? RETURN_ (opt_nullExclusion=OptNullExclusion subtypeMark=Name // TODO: check this rule
      	                                  | anonymousAccessDefinition=AnonymousAccessDefinition) 
    ;

FormalPart:
      PG parameterSpecifications+=ParameterSpecification (PV parameterSpecifications+=ParameterSpecification)* PD
    ;

ParameterSpecification:
      definingIdentifiers=DefiningIdentifierList DP 
      (mode=Mode optNullExclusion=OptNullExclusion subtypeMark=Name
     | anonymousAccessDefinition=AnonymousAccessDefinition ) 
      (DPE defaultExpression=Expression)?
    ;

Mode: {Mode}
     in ?= IN_? out ?= OUT_?
    ;

//Discrete_subtype_indication: TODO: To remove
//      subtypeIndication=Subtype_indication
//    ;
    
IntegerTypeDefinition:
	(
      SignedIntegerTypeDefinition
    | ModularTypeDefinition
    )
    ;

SignedIntegerTypeDefinition:
      RANGE_ first=SimpleExpression PP last=SimpleExpression
    ;

ModularTypeDefinition:
      MOD_ staticExpression=Expression
    ;

EnumerationTypeDefinition:
      PG enumerationliteralspecifications+=EnumerationLiteralSpecification (V enumerationliteralspecifications+=EnumerationLiteralSpecification)* PD
    ;

EnumerationLiteralSpecification:
      IDENTIFIER 
    | CHARACTER_LITERAL
    ;

RecordTypeDefinition:
      ((abstract?=ABSTRACT_)? tagged?=TAGGED_)? (limited?=LIMITED_)? recordDefinition=RecordDefinition
    ;

RecordDefinition:
     RECORD_ 
     (componentList=ComponentList
     | null=NULL_ PV
     ) 
     END_ RECORD_
   | null=NULL_ RECORD_
    ;

ComponentList:
	 (componentItems+=ComponentItem PV)* optVariantPart=OptVariantPart  // TODO: this is not strict enough, look at original def to see how we can make this strict enough OR validation
    ;

OptVariantPart: {OptVariantPart} (variantPart=VariantPart PV)? ;

ComponentItem:
	  ComponentDeclaration
	| AspectClause           // TODO: Check if it is really a RM's bug.
	;

ComponentDeclaration:
	  definingIdentifiers=DefiningIdentifierList DP componentDefinition=ComponentDefinition (DPE defaultExpression=Expression)?
	;
     
DefiningIdentifierList:
      name += IDENTIFIER (V name += IDENTIFIER)*
    ;

AspectClause: 
      FOR_ name=PATHNAME USE_ ( expression=Expression
                                  	// TODO: Check that the following syntactic constraint is satisfied:
                                  	//  Local_name "'" attributeDesignator = Attribute_designator USE_ expression=Expression
                                    //  Local_name USE_ (enumerationAggregate=Enumeration_aggregate 
                                       |RECORD_ 
                                           (mod=ModClause PV)? 
                                           (componentClause += ComponentClause PV)* 
                                         END_ RECORD_
                                       | AT_ expression=Expression
                                    // TODO: Check that name is Direct_name for AT_ expression alt                   
                                       ) 
    ;
        
ModClause:
        AT_ MOD_ mod=Expression
        ;        

ComponentClause:
        localName=PATHIDENTIFIER AT_ position=Expression RANGE_ firstBit=SimpleExpression PP lastBit = SimpleExpression
        ;

VariantPart:
      CASE_ name=DIRECT_NAME IS_ 
       (variants+=Variant)+ 
      END_ CASE_
    ;

Variant:
      WHEN_ discreteChoiceList=DiscreteChoiceList FLECHE componentList=ComponentList
    ;

DiscreteChoiceList:
      discreteChoiceList += DiscreteChoice (BV discreteChoiceList += DiscreteChoice)*
    ;

RealTypeDefinition:
      FloatingPointDefinition
    | FixedPointDefinition
    ;
        
FloatingPointDefinition:
      DIGITS_ digits = Expression realRangeSpecification = RealRangeSpecification?
    ;
        
RealRangeSpecification:
      RANGE_ lowerBound=SimpleExpression PP upperBound = SimpleExpression
    ; // TODO: semantic rule to check: lowerBound_ and upperBound_ are static 
        
FixedPointDefinition:
   DELTA_ delta = Expression
    (
      realRangeSpecification = RealRangeSpecification
    |
      DIGITS_ digits = Expression realRangeSpecification = RealRangeSpecification?
    )
    ;
    
    
///////////////////////////////////////////////////////////////////////////////
//
//                       Grammar module : EXPRESSIONS.XTEXT 
//
///////////////////////////////////////////////////////////////////////////////


Expression:
	relations+=Relation (booleanOperator += BooleanOperator relations+=Relation)* 
	;

BooleanOperator: 
	XOR_ | AND_ (THEN_)? | OR_ (ELSE_)?
;

Relation: 
	  simpleExpression = SimpleExpression
	 (relationalOperator=RelationalOperator subSimpleExpression = SimpleExpression
     | membership=Membership)? 
	;

Membership: (not?=NOT_)? IN_ interval=Interval;

Interval:  => Range | Name;

SimpleExpression:
	  (unaryAddingOperator=UnaryAddingOperator)? 
	  terms+=Term (binaryAddingOperators+=BinaryAddingOperator terms+=Term)*
    ;

Term:
      factors+=Factor (multiplyingOperators+=MultiplyingOperator factors+=Factor)*
    ;

Factor:
	(
	  primary = Primary (ETOI2 exponent=Primary)?
	| abs?=ABS_ primary=Primary
	| not?=NOT_ primary=Primary
	)
    ;

Primary:
	  NumericLiteral
	| Null   
	| StringLiteral
	| ParenthesizedExpression
	| QualifiedName       
	| Allocator
	;
	
NumericLiteral: value=NUMERIC_LITERAL;

Null: value=NULL_;

StringLiteral: value=STRING_LITERAL;


QualifiedName: name=Name qualifier=Qualifier?; // TODO: OPERATOR_SYMBOL is never followed by a Qualifier

ParenthesizedExpression: Aggregate;

Qualifier:
         QUOTE Aggregate // TODO: Semantic rule: Check Name is a subtype_mark 
        ;

Allocator:
        NEW_ typeName=Name qualifier=Qualifier? // TODO : Semantic Rule : Subtype_indication is never followed by qualifier.       
        ;

SubtypeIndication: 
	opt_nullExclusion=OptNullExclusion subtypeMark=PATHIDENTIFIER opt_constraint=OptConstraint // TODO: Check semantic rule : 'NOT NULL' only for access type, Name. 
    ;

OptNullExclusion: {OptNullExclusion}
      not_null=NullExclusion?
    ;
NullExclusion: NOT_ NULL_;

OptConstraint: {OptConstraint}
      optConstraint = ( CompositeConstraint 
	                  | ScalarConstraint)?
    ;

ScalarConstraint:
	  RangeConstraint
	| DigitsConstraint
	| DeltaConstraint
    ;

DigitsConstraint:
      DIGITS_ digits = SimpleExpression rangeConstraint = RangeConstraint?
    ;

DeltaConstraint:
        DELTA_ delta=SimpleExpression rangeConstraint = RangeConstraint?
        ;

RangeConstraint:
	  RANGE_ Range   
    ;

// TODO: Check that it is composed either of Discriminant associations, 
//       either of Discrete ranges 
//       NB: the latter designates range of indexes in arrays.
CompositeConstraint:
	      => DiscriminantConstraint
	    |    IndexConstraint
    ;

DiscriminantConstraint:
   PG discriminantAssociation += DiscriminantAssociation (V discriminantAssociation += DiscriminantAssociation)* PD
   ;

IndexConstraint: PG discreteRange += DiscreteRange (V discreteRange += DiscreteRange)* PD	
   ;

DiscriminantAssociation:
         discriminantSelectors = DiscriminantSelectors? actualParameter = Expression
        ;

DiscriminantSelectors: discriminantSelectorName += SelectorName 
                   	(BV discriminantSelectorName += SelectorName)* FLECHE;

DiscreteRange:
      => Range       
    |    SubtypeIndication
    ;

// TODO: Check the following syntactic rule 
//       (because this syntactic rule is unified with record aggregate)
//       NULL_ RECORD_ is not allowed for an array aggregate
//Component_association_list: {Record_component_association_list}
//          (componentAssociation += Component_association (V componentAssociation += Component_association)*
//        | nullRecord?=NULL_ RECORD_)
//        ;

// TODO: Check the following syntactic rule :
//       positional and named associations are not mixed
//       Other syntactic rule to check : "<>" must be associated with a non empty
//       componentChoiceList. 
//Component_association:{Component_association}
//         (=> componentsChoiceList=Component_choice_list FLECHE)? 
//         (expression = Expression | box?=BOIT)
//        ;

// TODO: Unified with Array aggregate
//       (i.e : Selector_name has been replaced by Dscrete_choice in Component_choice_list).
//       To balance this, check the following syntactic rule :
//       Discrete_range is equivalent to a Selector_name only for a record aggregate
ComponentChoiceList: 
	  componentSelectorName += SelectorName (BV componentSelectorName += SelectorName)*
    | others?=OTHERS_
    ;

DiscreteChoice:
		=> Range
	 |  => Expression // TODO: Could reduced to a name that is a subtype_indication
	 |     SubtypeIndication 
 	 |   {DiscreteChoice}  OTHERS_ 
    ;

// TODO : Because array aggregate rules are unified with record aggregate rules
//        check that an array aggregate is not preceded by Ancestor_part WITH_ 
Aggregate: PG (
             => ArrayAggregate 
           | => RecordAggregate
           |    ExtensionAggregate 
          ) PD
        ;

RecordAggregate: RecordComponentAssociationList
;

RecordComponentAssociationList: 
	recordComponentAssociation += RecordComponentAssociation (V recordComponentAssociation += RecordComponentAssociation)*
  | nullRecord?=NULL_ RECORD_;

RecordComponentAssociation:  
	 =>  InitializedComponents // TODO: Here is an ambiguity with Positional_array_aggregate for singleton '( value )'
   |     UninitializedComponents
   ;     // TODO: So, disambiguate by type checking thanks to the inferred type.

InitializedComponents: 
	(componentChoiceList+=ComponentChoiceList FLECHE)? value = Expression
;

UninitializedComponents: componentChoiceList+=ComponentChoiceList FLECHE box?=BOIT;


ExtensionAggregate: ancestorPart=AncestorPart WITH_ recordComponentAssociationList=RecordComponentAssociationList;

ArrayAggregate: => PositionalArrayAggregate 
	            |  NamedArrayAggregate 
;

PositionalArrayAggregate:
	initialValues += Expression (V initialValues += Expression)+           // TODO: Here is an ambiguity with Record_component_association for singleton '( value, value, ... )'
    (V OTHERS_ FLECHE (othersValue = Expression | othersBox?=BOIT))?       // So, disambiguate by type checking thanks to the inferred type.
  ;
NamedArrayAggregate:
    arrayComponentAssociation += ArrayComponentAssociation (V arrayComponentAssociation += ArrayComponentAssociation)* // TODO: Here is an ambiguity with Record_component_association_list
;
ArrayComponentAssociation: discreteChoiceList = DiscreteChoiceList FLECHE (expression = Expression | box?=BOIT)
;

AncestorPart:
          Expression // TODO: Expression could be a the name of a subtype
                     //       check this semantic rule.
        // | Name TODO: Remove this rule
        ;

PATHIDENTIFIER returns ecore::EString:
        (IDENTIFIER P)* IDENTIFIER;     

PATHNAME returns ecore::EString:
        (IDENTIFIER P)* DIRECT_NAME;  

DIRECT_NAME returns ecore::EString:
	  IDENTIFIER
    | OPERATOR_SYMBOL
	
;
        
Name: 
        name=SelectorName primaryName = PrimaryName?;
        
SelectorName:
        IDENTIFIER
      | CHARACTER_LITERAL
      | OPERATOR_SYMBOL
      ;                    

PrimaryName: {PrimaryName}
         // NB: Could be a Slice. ex: tab(1..4)
         //     could be a type conversion ex: Integer(3.14).
         //     could be a function call. NB: the only one that accepts param association
         //                                   so TODO: check this last semantic rule.
       ( PG parameterAssociation += ParameterAssociation (V parameterAssociation += ParameterAssociation)* PD (primaryName=PrimaryName)? 
       | P (ALL_ |  name=Name)        
       | QUOTE attributeDesignator = AttributeDesignator 
       )
       ;
        
ParameterAssociation:
        (selectorName=SelectorName FLECHE)? parameterEffectiveValue=ParameterEffectiveValue 
        ;

ParameterEffectiveValue: => Range   // Note : Discrete_range - Subtype_indication  
	                      | Expression // TODO: check Could be a Name that is a Subtype_indication.
	                       	                            //       then, It must be checked by a semantic rule.
//                           | => subtypeIndication = Subtype_indication	            // TODO: To delete very probably given what is said just above.           	                          
	
;

AttributeDesignator: {AttributeDesignator}
        ( IDENTIFIER (staticExpression = ParenthesizedExpression)?
        | ACCESS_
        | DELTA_
        | DIGITS_
        )
        ;

Range:	  	
	  => EntityRange
	  |  ExplicitRange
      ;

EntityRange: name=Name QUOTE RANGE_ (PG index = Expression PD)?;

ExplicitRange: first=SimpleExpression PP last=SimpleExpression;

BinaryAddingOperator:
	  PLUS
	| MOINS
	| ET_COM
	;

UnaryAddingOperator:
	  PLUS
	| MOINS
	;

MultiplyingOperator:
      ETOI
	| SLASH
	| MOD_      
	| REM_     
	;

RelationalOperator:
	  EG
	| DIFF
	| INF
	| INFE
	| SUP
	| SUPE
	;
	
///////////////////////////////////////////////////////////////////////////////
//
//                       Grammar module : Lexical.XTEXT 
//
///////////////////////////////////////////////////////////////////////////////


terminal ABORT_: "abort" ;
terminal ABS_: "abs" ; 
terminal ABSTRACT_: "abstract" ;
terminal ACCEPT_: "accept" ;
terminal ACCESS_: "access" ;
terminal ALIASED_: "aliased" ;
terminal ALL_: "all" ;
terminal AND_: "and" ;
terminal ARRAY_: "array" ; 
terminal AT_: "at" ;
terminal BEGIN_: "begin" ;
terminal BODY_: "body" ;
terminal CASE_: "case" ; 
terminal CONSTANT_: "constant" ; 
terminal DECLARE_: "declare" ; 
terminal DELAY_: "delay" ; 
terminal DELTA_: "delta" ; 
terminal DIGITS_: "digits" ;
terminal DO_: "do" ; 
terminal ELSE_: "else" ; 
terminal ELSIF_: "elsif" ;
terminal END_: "end" ; 
terminal ENTRY_: "entry" ;
terminal EXCEPTION_: "exception" ; 
terminal EXIT_: "exit" ; 
terminal FOR_: "for" ;
terminal FUNCTION_: "function" ; 
terminal GENERIC_: "generic" ; 
terminal GOTO_: "goto" ; 
terminal IF_: "if" ; 
terminal IN_: "in" ;
terminal INTERFACE_: "interface" ; 
terminal IS_: "is" ; 
terminal LIMITED_: "limited" ; 
terminal LOOP_: "loop" ; 
terminal MOD_: "mod" ; 
terminal NEW_: "new" ; 
terminal NOT_: "not" ; 
terminal NULL_: "null" ; 
terminal OF_: "of" ; 
terminal OR_: "or" ; 
terminal OTHERS_: "others" ; 
terminal OUT_: "out" ; 
terminal OVERRIDING_: "overriding" ; 
terminal PACKAGE_: "package" ; 
terminal PRAGMA_: "pragma" ; 
terminal PRIVATE_: "private" ;
terminal PROCEDURE_: "procedure" ;
terminal PROTECTED_: "protected" ;
terminal RAISE_: "raise" ;
terminal RANGE_: "range" ;
terminal RECORD_: "record" ;
terminal REM_: "rem" ;
terminal RENAMES_: "renames" ;
terminal REQUEUE_: "requeue" ;
terminal RETURN_: "return" ;
terminal REVERSE_: "reverse" ;
terminal SELECT_: "select" ;
terminal SEPARATE_: "separate" ;
terminal SUBTYPE_: "subtype" ;
terminal SYNCHRONIZED_: "synchronized" ;
terminal TAGGED_: "tagged" ;
terminal TASK_: "task" ;
terminal TERMINATE_: "terminate" ;
terminal THEN_: "then" ;
terminal TYPE_: "type" ;
terminal UNTIL_: "until" ;
terminal USE_: "use" ;
terminal WHEN_: "when" ;
terminal WHILE_: "while" ;
terminal WITH_: "with" ;
terminal XOR_: "xor" ; 

terminal NUMERIC_LITERAL:
      DECIMAL_LITERAL
    | BASED_LITERAL
    ;

terminal fragment DECIMAL_LITERAL:
      NUMERAL (P NUMERAL)? EXPONENT?
    ;
    
terminal fragment NUMERAL:
      DIGIT ('_'? DIGIT)*
    ;

terminal WS: 
	  ('\u0020'|'\t'|'\r'|'\n')+
	;

terminal IDENTIFIER: '^'
	 //IDENTIFIER_START (IDENTIFIER_START | IDENTIFIER_EXTEND)*
    ;

terminal fragment IDENTIFIER_START:
      LETTER_UPPERCASE
    | LETTER_LOWERCASE
    | LETTER_TITLECASE
    | LETTER_MODIFIER
    //| LETTER_OTHER  //TODO: Fix it and uncomment
    | NUMBER_LETTER
    ;

terminal fragment LETTER_UPPERCASE:
	'A' .. 'Z'
    ;
        
terminal fragment LETTER_LOWERCASE:
	'a' .. 'z'
    ;        

terminal fragment LETTER_TITLECASE:
'\u01C5' | '\u01C8' | '\u01CB' | '\u01F2' | '\u1F88' .. '\u1F8F' |
'\u1F98' .. '\u1F9F' | '\u1FA8' .. '\u1FAF' | '\u1FBC' | '\u1FCC' |
'\u1FFC'
  ;  
      
terminal fragment LETTER_MODIFIER:
'\u02B0' .. '\u02C1' | '\u02C6' .. '\u02D1' | '\u02E0' .. '\u02E4' |
'\u02EC' | '\u02EE' | '\u0374' | '\u037A' | '\u0559' | '\u0640' |
'\u06E5' | '\u06E6' | '\u07F4' | '\u07F5' | '\u07FA' | '\u081A' |
'\u0824' | '\u0828' | '\u0971' | '\u0E46' | '\u0EC6' | '\u10FC' |
'\u17D7' | '\u1843' | '\u1AA7' | '\u1C78' .. '\u1C7D' |
'\u1D2C' .. '\u1D6A' | '\u1D78' | '\u1D9B' .. '\u1DBF' | '\u2071' |
'\u207F' | '\u2090' .. '\u209C' | '\u2C7C' | '\u2C7D' | '\u2D6F' |
'\u2E2F' | '\u3005' | '\u3031' .. '\u3035' | '\u303B' | '\u309D' |
'\u309E' | '\u30FC' .. '\u30FE' | '\uA015' | '\uA4F8' .. '\uA4FD' |
'\uA60C' | '\uA67F' | '\uA717' .. '\uA71F' | '\uA770' | '\uA788' |
'\uA7F8' | '\uA7F9' | '\uA9CF' | '\uAA70' | '\uAADD' | '\uAAF3' |
'\uAAF4' | '\uFF70' | '\uFF9E' | '\uFF9F' //| '\u16F93' .. '\u16F9F' is not accepted by ANTLR. TODO: See what to do
    ;      

terminal fragment LETTER_OTHER:
'\u00AA' | '\u00BA' | '\u01BB' | '\u01C0' | '\u01C3' | '\u0294' | 
'\u05D0' | '\u05EA' | '\u05F0' | '\u05F2' | '\u0620' | '\u063F' | '\u0641' | '\u064A' | '\u066E' | '\u066F' | '\u0671' | '\u06D3' | 
'\u06D5' | '\u06EE' | '\u06EF' | '\u06FA' | '\u06FC' | '\u06FF' | '\u0710' | '\u0712' | '\u072F' | 
'\u074D' | '\u07A5' | '\u07B1' | '\u07CA' | '\u07EA' | '\u0800' | '\u0815' | '\u0840' | '\u0858' | '\u08A0' | 
'\u08A2' | '\u08AC' | '\u0904' | '\u0939' | '\u093D' | '\u0950' | '\u0958' | '\u0961' | '\u0972' | '\u0977' | 
'\u0979' | '\u097F' | '\u0985' | '\u098C' | '\u098F' | '\u0990' | '\u0993' | '\u09A8' | '\u09AA' | '\u09B0' | '\u09B2' | 
'\u09B6' | '\u09B9' | '\u09BD' | '\u09CE' | '\u09DC' | '\u09DD' | '\u09DF' | '\u09E1' | '\u09F0' | '\u09F1' | 
'\u0A05' | '\u0A0A' | '\u0A0F' | '\u0A10' | '\u0A13' | '\u0A28' | '\u0A2A' | '\u0A30' | '\u0A32' | '\u0A33' | '\u0A35' | '\u0A36' | 
'\u0A38' | '\u0A39' | '\u0A59' | '\u0A5C' | '\u0A5E' | '\u0A72' | '\u0A74' | '\u0A85' | '\u0A8D' | '\u0A8F' | '\u0A91' | 
'\u0A93' | '\u0AA8' | '\u0AAA' | '\u0AB0' | '\u0AB2' | '\u0AB3' | '\u0AB5' | '\u0AB9' | '\u0ABD' | '\u0AD0' | 
'\u0AE0' | '\u0AE1' | '\u0B05' | '\u0B0C' | '\u0B0F' | '\u0B10' | '\u0B13' | '\u0B28' | '\u0B2A' | '\u0B30' | '\u0B32' | '\u0B33' | 
'\u0B35' | '\u0B39' | '\u0B3D' | '\u0B5C' | '\u0B5D' | '\u0B5F' | '\u0B61' | '\u0B71' | '\u0B83' | 
'\u0B85' | '\u0B8A' | '\u0B8E' | '\u0B90' | '\u0B92' | '\u0B95' | '\u0B99' | '\u0B9A' | '\u0B9C' | '\u0B9E' | '\u0B9F' | 
'\u0BA3' | '\u0BA4' | '\u0BA8' | '\u0BAA' | '\u0BAE' | '\u0BB9' | '\u0BD0' | '\u0C05' | '\u0C0C' | '\u0C0E' | '\u0C10' | 
'\u0C12' | '\u0C28' | '\u0C2A' | '\u0C33' | '\u0C35' | '\u0C39' | '\u0C3D' | '\u0C58' | '\u0C59' | '\u0C60' | '\u0C61' | 
'\u0C85' | '\u0C8C' | '\u0C8E' | '\u0C90' | '\u0C92' | '\u0CA8' | '\u0CAA' | '\u0CB3' | '\u0CB5' | '\u0CB9' | '\u0CBD' | 
'\u0CDE' | '\u0CE0' | '\u0CE1' | '\u0CF1' | '\u0CF2' | '\u0D05' | '\u0D0C' | '\u0D0E' | '\u0D10' | '\u0D12' | '\u0D3A' | 
'\u0D3D' | '\u0D4E' | '\u0D60' | '\u0D61' | '\u0D7A' | '\u0D7F' | '\u0D85' | '\u0D96' | '\u0D9A' | '\u0DB1' | 
'\u0DB3' | '\u0DBB' | '\u0DBD' | '\u0DC0' | '\u0DC6' | '\u0E01' | '\u0E30' | '\u0E32' | '\u0E33' | '\u0E40' | '\u0E45' | 
'\u0E81' | '\u0E82' | '\u0E84' | '\u0E87' | '\u0E88' | '\u0E8A' | '\u0E8D' | '\u0E94' | '\u0E97' | 
'\u0E99' | '\u0E9F' | '\u0EA1' | '\u0EA3' | '\u0EA5' | '\u0EA7' | '\u0EAA' | '\u0EAB' | '\u0EAD' | '\u0EB0' | 
'\u0EB2' | '\u0EB3' | '\u0EBD' | '\u0EC0' | '\u0EC4' | '\u0EDC' | '\u0EDF' | '\u0F00' | '\u0F40' | '\u0F47' | 
'\u0F49' | '\u0F6C' | '\u0F88' | '\u0F8C' | '\u1000' | '\u102A' | '\u103F' | '\u1050' | '\u1055' | '\u105A' | '\u105D' | 
'\u1061' | '\u1065' | '\u1066' | '\u106E' | '\u1070' | '\u1075' | '\u1081' | '\u108E' | '\u10D0' | '\u10FA' | 
'\u10FD' | '\u1248' | '\u124A' | '\u124D' | '\u1250' | '\u1256' | '\u1258' | '\u125A' | '\u125D' | '\u1260' | '\u1288' | 
'\u128A' | '\u128D' | '\u1290' | '\u12B0' | '\u12B2' | '\u12B5' | '\u12B8' | '\u12BE' | '\u12C0' | '\u12C2' | '\u12C5' | 
'\u12C8' | '\u12D6' | '\u12D8' | '\u1310' | '\u1312' | '\u1315' | '\u1318' | '\u135A' | '\u1380' | '\u138F' | '\u13A0' | '\u13F4' | 
'\u1401' | '\u166C' | '\u166F' | '\u167F' | '\u1681' | '\u169A' | '\u16A0' | '\u16EA' | '\u1700' | '\u170C' | '\u170E' | '\u1711' | 
'\u1720' | '\u1731' | '\u1740' | '\u1751' | '\u1760' | '\u176C' | '\u176E' | '\u1770' | '\u1780' | '\u17B3' | '\u17DC' | 
'\u1820' | '\u1842' | '\u1844' | '\u1877' | '\u1880' | '\u18A8' | '\u18AA' | '\u18B0' | '\u18F5' | '\u1900' | '\u191C' | 
'\u1950' | '\u196D' | '\u1970' | '\u1974' | '\u1980' | '\u19AB' | '\u19C1' | '\u19C7' | '\u1A00' | '\u1A16' | '\u1A20' | '\u1A54' | 
'\u1B05' | '\u1B33' | '\u1B45' | '\u1B4B' | '\u1B83' | '\u1BA0' | '\u1BAE' | '\u1BAF' | '\u1BBA' | '\u1BE5' | '\u1C00' | '\u1C23' | 
'\u1C4D' | '\u1C4F' | '\u1C5A' | '\u1C77' | '\u1CE9' | '\u1CEC' | '\u1CEE' | '\u1CF1' | '\u1CF5' | '\u1CF6' | '\u2135' | '\u2138' | 
'\u2D30' | '\u2D67' | '\u2D80' | '\u2D96' | '\u2DA0' | '\u2DA6' | '\u2DA8' | '\u2DAE' | '\u2DB0' | '\u2DB6' | '\u2DB8' | '\u2DBE' | 
'\u2DC0' | '\u2DC6' | '\u2DC8' | '\u2DCE' | '\u2DD0' | '\u2DD6' | '\u2DD8' | '\u2DDE' | '\u3006' | '\u303C' | 
'\u3041' | '\u3096' | '\u309F' | '\u30A1' | '\u30FA' | '\u30FF' | '\u3105' | '\u312D' | '\u3131' | '\u318E' | 
'\u31A0' | '\u31BA' | '\u31F0' | '\u31FF' | '\u3400' | '\u4DB5' | '\u4E00' | '\u9FCC' | 
'\uA000' | '\uA014' | '\uA016' | '\uA48C' | '\uA4D0' | '\uA4F7' | '\uA500' | '\uA60B' | '\uA610' | '\uA61F' | '\uA62A' | '\uA62B' | 
'\uA66E' | '\uA6A0' | '\uA6E5' | '\uA7FB' | '\uA801' | '\uA803' | '\uA805' | '\uA807' | '\uA80A' | '\uA80C' | '\uA822' | 
'\uA840' | '\uA873' | '\uA882' | '\uA8B3' | '\uA8F2' | '\uA8F7' | '\uA8FB' | '\uA90A' | '\uA925' | '\uA930' | '\uA946' | 
'\uA960' | '\uA97C' | '\uA984' | '\uA9B2' | '\uAA00' | '\uAA28' | '\uAA40' | '\uAA42' | '\uAA44' | '\uAA4B' | '\uAA60' | '\uAA6F' | 
'\uAA71' | '\uAA76' | '\uAA7A' | '\uAA80' | '\uAAAF' | '\uAAB1' | '\uAAB5' | '\uAAB6' | '\uAAB9' | '\uAABD' | 
'\uAAC0' | '\uAAC2' | '\uAADB' | '\uAADC' | '\uAAE0' | '\uAAEA' | '\uAAF2' | '\uAB01' | '\uAB06' | 
'\uAB09' | '\uAB0E' | '\uAB11' | '\uAB16' | '\uAB20' | '\uAB26' | '\uAB28' | '\uAB2E' | '\uABC0' | '\uABE2' | '\uAC00' | 
'\uD7A3' | '\uD7B0' | '\uD7C6' | '\uD7CB' | '\uD7FB' | '\uF900' | '\uFA6D' | '\uFA70' | '\uFAD9' | '\uFB1D' | 
'\uFB1F' | '\uFB28' | '\uFB2A' | '\uFB36' | '\uFB38' | '\uFB3C' | '\uFB3E' | '\uFB40' | '\uFB41' | '\uFB43' | '\uFB44' | 
'\uFB46' | '\uFBB1' | '\uFBD3' | '\uFD3D' | '\uFD50' | '\uFD8F' | '\uFD92' | '\uFDC7' | '\uFDF0' | '\uFDFB' | '\uFE70' | '\uFE74' | 
'\uFE76' | '\uFEFC' | '\uFF66' | '\uFF6F' | '\uFF71' | '\uFF9D' | '\uFFA0' | '\uFFBE' | '\uFFC2' | '\uFFC7' | '\uFFCA' | '\uFFCF' | 
'\uFFD2' | '\uFFD7' | '\uFFDA' | '\uFFDC' | '\u10000' | '\u1000B' //| '\u1000D' | '\u10026' | '\u10028' | '\u1003A' | '\u1003C' | '\u1003D' | 
//'\u1003F' | '\u1004D' | '\u10050' | '\u1005D' | '\u10080' | '\u100FA' | '\u10280' | '\u1029C' | '\u102A0' | '\u102D0' | '\u10300' | '\u1031E' | 
//'\u10330' | '\u10340' | '\u10342' | '\u10349' | '\u10380' | '\u1039D' | '\u103A0' | '\u103C3' | '\u103C8' | '\u103CF' | '\u10450' | '\u1049D' | 
//'\u10800' | '\u10805' | '\u10808' | '\u1080A' | '\u10835' | '\u10837' | '\u10838' | '\u1083C' | '\u1083F' | '\u10855' | 
//'\u10900' | '\u10915' | '\u10920' | '\u10939' | '\u10980' | '\u109B7' | '\u109BE' | '\u109BF' | '\u10A00' | '\u10A10' | '\u10A13' | 
//'\u10A15' | '\u10A17' | '\u10A19' | '\u10A33' | '\u10A60' | '\u10A7C' | '\u10B00' | '\u10B35' | '\u10B40' | '\u10B55' | '\u10B60' | '\u10B72' | 
//'\u10C00' | '\u10C48' | '\u11003' | '\u11037' | '\u11083' | '\u110AF' | '\u110D0' | '\u110E8' | '\u11103' | '\u11126' | '\u11183' | '\u111B2' | 
//'\u111C1' | '\u111C4' | '\u11680' | '\u116AA' | '\u12000' | '\u1236E' | '\u13000' | '\u1342E' | '\u16800' | '\u16A38' | '\u16F00' | '\u16F44' | 
//'\u16F50' | '\u1B000' | '\u1B001' | '\u1EE00' | '\u1EE03' | '\u1EE05' | '\u1EE1F' | '\u1EE21' | '\u1EE22' | '\u1EE24' | 
//'\u1EE27' | '\u1EE29' | '\u1EE32' | '\u1EE34' | '\u1EE37' | '\u1EE39' | '\u1EE3B' | '\u1EE42' | 
//'\u1EE47' | '\u1EE49' | '\u1EE4B' | '\u1EE4D' | '\u1EE4F' | '\u1EE51' | '\u1EE52' | '\u1EE54' | 
//'\u1EE57' | '\u1EE59' | '\u1EE5B' | '\u1EE5D' | '\u1EE5F' | '\u1EE61' | '\u1EE62' | 
//'\u1EE64' | '\u1EE67' | '\u1EE6A' | '\u1EE6C' | '\u1EE72' | '\u1EE74' | '\u1EE77' | '\u1EE79' | '\u1EE7C' | '\u1EE7E' | 
//'\u1EE80' | '\u1EE89' | '\u1EE8B' | '\u1EE9B' | '\u1EEA1' | '\u1EEA3' | '\u1EEA5' | '\u1EEA9' | '\u1EEAB' | '\u1EEBB' | '\u20000' | 
//'\u2A6D6' | '\u2A700' | '\u2B734' | '\u2B740' | '\u2B81D' | '\u2F800' | '\u2FA1D'  // TODO: Fix unicode
    ; 

terminal fragment NUMBER_LETTER:
'\u16EE' ..  '\u16F0' | '\u2160' ..  '\u2182' | '\u2185' ..  '\u2188' | '\u3007' | '\u3021' ..  '\u3029' | 
'\u3038' ..  '\u303A' | '\uA6E6' ..  '\uA6EF' // | '\u10140' ..  '\u10174' | '\u10341' | '\u1034A' | '\u103D1' ..  '\u103D5' | is not accepted by ANTLR. TODO: See what to do 
//'\u12400' ..  '\u12462' is not accepted by ANTLR. TODO: See what to do   // TODO: Fix unicode
    ;	
	
terminal fragment IDENTIFIER_EXTEND:
        MARKNON_SPACING
      | MARKSPACING_COMBINING
      | NUMBER_DECIMAL
      | PUNCTUATION_CONNECTOR
      | OTHER_FORMAT
    ;
    
terminal fragment NUMBER_DECIMAL:
'\u0030' .. '\u0039' | '\u0660' .. '\u0669' | '\u06F0' .. '\u06F9' | '\u07C0' .. '\u07C9' | '\u0966' .. '\u096F' | 
'\u09E6' .. '\u09EF' | '\u0A66' .. '\u0A6F' | '\u0AE6' .. '\u0AEF' | '\u0B66' .. '\u0B6F' | '\u0BE6' .. '\u0BEF' | '\u0C66' .. '\u0C6F' | 
'\u0CE6' .. '\u0CEF' | '\u0D66' .. '\u0D6F' | '\u0E50' .. '\u0E59' | '\u0ED0' .. '\u0ED9' | '\u0F20' .. '\u0F29' | '\u1040' .. '\u1049' | 
'\u1090' .. '\u1099' | '\u17E0' .. '\u17E9' | '\u1810' .. '\u1819' | '\u1946' .. '\u194F' | '\u19D0' .. '\u19D9' | '\u1A80' .. '\u1A89' | 
'\u1A90' .. '\u1A99' | '\u1B50' .. '\u1B59' | '\u1BB0' .. '\u1BB9' | '\u1C40' .. '\u1C49' | '\u1C50' .. '\u1C59' | '\uA620' .. '\uA629' | 
'\uA8D0' .. '\uA8D9' | '\uA900' .. '\uA909' | '\uA9D0' .. '\uA9D9' | '\uAA50' .. '\uAA59' | '\uABF0' .. '\uABF9' | '\uFF10' .. '\uFF19' //| 
// '\u104A0' .. '\u104A9' | '\u11066' .. '\u1106F' | '\u110F0' .. '\u110F9' | '\u11136' .. '\u1113F' | '\u111D0' .. '\u111D9' | '\u116C0' .. '\u116C9' | is not accepted by ANTLR. TODO: See what to do 
// '\u1D7CE' .. '\u1D7FF' is not accepted by ANTLR. TODO: See what to do    // TODO: Fix unicode
;    

terminal fragment MARKSPACING_COMBINING:
	'\u0903' | '\u093B' | '\u093E' .. '\u0940' | '\u0949' .. '\u094C' | '\u094E' | '\u094F' | 
'\u0982' | '\u0983' | '\u09BE' .. '\u09C0' | '\u09C7' | '\u09C8' | '\u09CB' | '\u09CC' | '\u09D7' | '\u0A03' | 
'\u0A3E' .. '\u0A40' | '\u0A83' | '\u0ABE' .. '\u0AC0' | '\u0AC9' | '\u0ACB' | '\u0ACC' | '\u0B02' | '\u0B03' | 
'\u0B3E' | '\u0B40' | '\u0B47' | '\u0B48' | '\u0B4B' | '\u0B4C' | '\u0B57' | '\u0BBE' | '\u0BBF' | 
'\u0BC1' | '\u0BC2' | '\u0BC6' .. '\u0BC8' | '\u0BCA' .. '\u0BCC' | '\u0BD7' | '\u0C01' .. '\u0C03' | '\u0C41' .. '\u0C44' | 
'\u0C82' | '\u0C83' | '\u0CBE' | '\u0CC0' .. '\u0CC4' | '\u0CC7' | '\u0CC8' | '\u0CCA' | '\u0CCB' | '\u0CD5' | '\u0CD6' | 
'\u0D02' | '\u0D03' | '\u0D3E' .. '\u0D40' | '\u0D46' .. '\u0D48' | '\u0D4A' .. '\u0D4C' | '\u0D57' | '\u0D82' | '\u0D83' | 
'\u0DCF' .. '\u0DD1' | '\u0DD8' .. '\u0DDF' | '\u0DF2' | '\u0DF3' | '\u0F3E' | '\u0F3F' | '\u0F7F' | '\u102B' | '\u102C' | 
'\u1031' | '\u1038' | '\u103B' | '\u103C' | '\u1056' | '\u1057' | '\u1062' .. '\u1064' | '\u1067' .. '\u106D' | 
'\u1083' | '\u1084' | '\u1087' .. '\u108C' | '\u108F' | '\u109A' .. '\u109C' | '\u17B6' | '\u17BE' .. '\u17C5' | 
'\u17C7' | '\u17C8' | '\u1923' .. '\u1926' | '\u1929' .. '\u192B' | '\u1930' | '\u1931' | '\u1933' .. '\u1938' | '\u19B0' .. '\u19C0' | 
'\u19C8' | '\u19C9' | '\u1A19' .. '\u1A1B' | '\u1A55' | '\u1A57' | '\u1A61' | '\u1A63' | '\u1A64' | 
'\u1A6D' .. '\u1A72' | '\u1B04' | '\u1B35' | '\u1B3B' | '\u1B3D' .. '\u1B41' | '\u1B43' | '\u1B44' | 
'\u1B82' | '\u1BA1' | '\u1BA6' | '\u1BA7' | '\u1BAA' | '\u1BAC' | '\u1BAD' | '\u1BE7' | 
'\u1BEA' .. '\u1BEC' | '\u1BEE' | '\u1BF2' | '\u1BF3' | '\u1C24' .. '\u1C2B' | '\u1C34' | '\u1C35' | '\u1CE1' | 
'\u1CF2' | '\u1CF3' | '\u302E' | '\u302F' | '\uA823' | '\uA824' | '\uA827' | '\uA880' | '\uA881' | '\uA8B4' .. '\uA8C3' | 
'\uA952' | '\uA953' | '\uA983' | '\uA9B4' | '\uA9B5' | '\uA9BA' | '\uA9BB' | '\uA9BD' .. '\uA9C0' | '\uAA2F' | '\uAA30' | 
'\uAA33' | '\uAA34' | '\uAA4D' | '\uAA7B' | '\uAAEB' | '\uAAEE' | '\uAAEF' | '\uAAF5' | 
'\uABE3' | '\uABE4' | '\uABE6' | '\uABE7' | '\uABE9' | '\uABEA' | '\uABEC' | '\u11000' | '\u11002' //| 
// '\u11082' | '\u110B0' .. '\u110B2' | '\u110B7' | '\u110B8' | '\u1112C' | '\u11182' | '\u111B3' .. '\u111B5' |  is not accepted by ANTLR. TODO: See what to do 
// '\u111BF' | '\u111C0' | '\u116AC' | '\u116AE' | '\u116AF' | '\u116B6' | '\u16F51' .. '\u16F7E' | '\u1D165' | '\u1D166' | is not accepted by ANTLR. TODO: See what to do 
//'\u1D16D' .. '\u1D172' is not accepted by ANTLR. TODO: See what to do   // TODO: Fix unicode
;

terminal fragment OTHER_FORMAT:
'\u00AD' | '\u0600' .. '\u0604' | '\u06DD' | '\u070F' | '\u200B' .. '\u200F' |
'\u202A' .. '\u202E' | '\u2060' .. '\u2064' | '\u206A' .. '\u206F' |
'\uFEFF' | '\uFFF9' .. '\uFFFB' //| '\u110BD' | '\u1D173' .. '\u1D17A' |
//'\uE0001' | '\uE0020' .. '\uE007F'
;
    
terminal fragment MARKNON_SPACING:
'\u0300' .. '\u036F' | '\u0483' .. '\u0487' | '\u0591' .. '\u05BD' |
'\u05BF' | '\u05C1' | '\u05C2' | '\u05C4' | '\u05C5' | '\u05C7' | 
'\u0610' .. '\u061A' | '\u064B' .. '\u065F' | '\u0670' | 
'\u06D6' .. '\u06DC' | '\u06DF' .. '\u06E4' | '\u06E7' |
'\u06E8' | '\u06EA' .. '\u06ED' | '\u0711' | '\u0730' .. '\u074A' |
'\u07A6' .. '\u07B0' | '\u07EB' .. '\u07F3' | '\u0816' .. '\u0819' |
'\u081B' .. '\u0823' | '\u0825' .. '\u0827' | '\u0829' .. '\u082D' |
'\u0859' .. '\u085B' | '\u08E4' .. '\u08FE' | '\u0900' .. '\u0902' |
'\u093A' | '\u093C' | '\u0941' .. '\u0948' | '\u094D' |
'\u0951' .. '\u0957' | '\u0962' | '\u0963' | '\u0981' |
'\u09BC' | '\u09C1' .. '\u09C4' | '\u09CD' | '\u09E2' | '\u09E3' |
'\u0A01' | '\u0A02' | '\u0A3C' | '\u0A41' | '\u0A42' | '\u0A47' |
'\u0A48' | '\u0A4B' .. '\u0A4D' | '\u0A51' | '\u0A70' | '\u0A71' |
'\u0A75' | '\u0A81' | '\u0A82' | '\u0ABC' | '\u0AC1' .. '\u0AC5' |
'\u0AC7' | '\u0AC8' | '\u0ACD' | '\u0AE2' | '\u0AE3' | '\u0B01' |
'\u0B3C' | '\u0B3F' | '\u0B41' .. '\u0B44' | '\u0B4D' | '\u0B56' |
'\u0B62' | '\u0B63' | '\u0B82' | '\u0BC0' | '\u0BCD' | '\u0C3E' .. '\u0C40' |
'\u0C46' .. '\u0C48' | '\u0C4A' .. '\u0C4D' | '\u0C55' | '\u0C56' | '\u0C62' |
'\u0C63' | '\u0CBC' | '\u0CBF' | '\u0CC6' | '\u0CCC' | '\u0CCD' | '\u0CE2' |
'\u0CE3' | '\u0D41' .. '\u0D44' | '\u0D4D' | '\u0D62' | '\u0D63' | '\u0DCA' |
'\u0DD2' .. '\u0DD4' | '\u0DD6' | '\u0E31' | '\u0E34' .. '\u0E3A' |
'\u0E47' .. '\u0E4E' | '\u0EB1' | '\u0EB4' .. '\u0EB9' | '\u0EBB' |
'\u0EBC' | '\u0EC8' .. '\u0ECD' | '\u0F18' | '\u0F19' | '\u0F35' |
'\u0F37' | '\u0F39' | '\u0F71' .. '\u0F7E' | '\u0F80' .. '\u0F84' |
'\u0F86' | '\u0F87' | '\u0F8D' .. '\u0F97' | '\u0F99' .. '\u0FBC' |
'\u0FC6' | '\u102D' .. '\u1030' | '\u1032' .. '\u1037' | '\u1039' |
'\u103A' | '\u103D' | '\u103E' | '\u1058' | '\u1059' | '\u105E' .. '\u1060' |
'\u1071' .. '\u1074' | '\u1082' | '\u1085' | '\u1086' | '\u108D' |
'\u109D' | '\u135D' .. '\u135F' | '\u1712' .. '\u1714' | '\u1732' .. '\u1734' |
'\u1752' | '\u1753' | '\u1772' | '\u1773' | '\u17B4' | '\u17B5' | '\u17B7' .. '\u17BD' |
'\u17C6' | '\u17C9' .. '\u17D3' | '\u17DD' | '\u180B' .. '\u180D' | '\u18A9' |
'\u1920' .. '\u1922' | '\u1927' | '\u1928' | '\u1932' | '\u1939' .. '\u193B' |
'\u1A17' | '\u1A18' | '\u1A56' | '\u1A58' .. '\u1A5E' | '\u1A60' | '\u1A62' |
'\u1A65' .. '\u1A6C' | '\u1A73' .. '\u1A7C' | '\u1A7F' | '\u1B00' .. '\u1B03' |
'\u1B34' | '\u1B36' .. '\u1B3A' | '\u1B3C' | '\u1B42' | '\u1B6B' .. '\u1B73' |
'\u1B80' | '\u1B81' | '\u1BA2' .. '\u1BA5' | '\u1BA8' | '\u1BA9' | '\u1BAB' |
'\u1BE6' | '\u1BE8' | '\u1BE9' | '\u1BED' | '\u1BEF' .. '\u1BF1' | '\u1C2C' .. '\u1C33' |
'\u1C36' | '\u1C37' | '\u1CD0' .. '\u1CD2' | '\u1CD4' .. '\u1CE0' | '\u1CE2' .. '\u1CE8' |
'\u1CED' | '\u1CF4' | '\u1DC0' .. '\u1DE6' | '\u1DFC' .. '\u1DFF' | '\u20D0' .. '\u20DC' |
'\u20E1' | '\u20E5' .. '\u20F0' | '\u2CEF' .. '\u2CF1' | '\u2D7F' | '\u2DE0' .. '\u2DFF' |
'\u302A' .. '\u302D' | '\u3099' | '\u309A' | '\uA66F' |'\uA674' .. '\uA67D' |
'\uA69F' | '\uA6F0' | '\uA6F1' | '\uA802' | '\uA806' | '\uA80B' | '\uA825' |
'\uA826' | '\uA8C4' | '\uA8E0' .. '\uA8F1' | '\uA926' .. '\uA92D' | '\uA947' .. '\uA951' |
'\uA980' .. '\uA982' | '\uA9B3' | '\uA9B6' .. '\uA9B9' | '\uA9BC' | '\uAA29' .. '\uAA2E' |
'\uAA31' | '\uAA32' | '\uAA35' | '\uAA36' | '\uAA43' | '\uAA4C' | '\uAAB0' |
'\uAAB2' .. '\uAAB4' | '\uAAB7' | '\uAAB8' | '\uAABE' | '\uAABF' | '\uAAC1' |
'\uAAEC' | '\uAAED' | '\uAAF6' | '\uABE5' | '\uABE8' | '\uABED' | '\uFB1E' |
'\uFE00' .. '\uFE0F' | '\uFE20' .. '\uFE26' //| '\u101FD' | '\u10A01' .. '\u10A03' | 
//'\u10A05' | '\u10A06' | '\u10A0C' .. '\u10A0F' | '\u10A38' .. '\u10A3A' | '\u10A3F' | 
//'\u11001' | '\u11038' .. '\u11046' | '\u11080' | '\u11081' | '\u110B3' .. '\u110B6' |
//'\u110B9' | '\u110BA' | '\u11100' .. '\u11102' | '\u11127' .. '\u1112B' | '\u1112D' .. '\u11134' |
//'\u11180' | '\u11181' | '\u111B6' .. '\u111BE' | '\u116AB' | '\u116AD' | '\u116B0' .. '\u116B5' |
//'\u116B7' | '\u16F8F' .. '\u16F92' | '\u1D167' .. '\u1D169' | '\u1D17B' .. '\u1D182' |
//'\u1D185' .. '\u1D18B' | '\u1D1AA' .. '\u1D1AD' | '\u1D242' .. '\u1D244' | '\uE0100' .. '\uE01EF'	  // TODO: Fix unicode
 ;
    

terminal fragment PUNCTUATION_CONNECTOR:
'\u005F' | '\u203F' | '\u2040' | '\u2054' | '\uFE33' | '\uFE34' | '\uFE4D' .. '\uFE4F' | 
'\uFF3F'	
    ;

terminal fragment EXPONENT:
     ("E" | "e") ("-" | "+"?) NUMERAL
    ;
        
terminal fragment DIGIT:
      "0"
    | "1"
    | "2"
    | "3"
    | "4"
    | "5"
    | "6"
    | "7"
    | "8"
    | "9"
    ;
        
terminal fragment BASED_LITERAL:
    BASE "#" BASED_NUMERAL (P BASED_NUMERAL)? "#" EXPONENT?
    ;

terminal fragment BASE:
    NUMERAL
    ;

terminal fragment BASED_NUMERAL:
    EXTENDED_DIGIT ('_'? EXTENDED_DIGIT)*
    ;

terminal fragment EXTENDED_DIGIT:
      DIGIT
    | "A"
    | "B"
    | "C"
    | "D"
    | "E"
    | "F"
    ;

terminal CHARACTER_LITERAL:
      '\u0027' GRAPHIC_CHARACTER '\u0027'
    ;

terminal fragment GRAPHIC_CHARACTER:
      '\u0020' ..  '\u1FFF' // '\uFFFF' //'\u10FFFF'          // TODO: Fix UNICODE and escape chars
    ;

terminal OPERATOR_SYMBOL:
     '"' 
    ("and" | "or" | "xor" | '=' 
    | '/=' | '<'  | '<=' | '>' 
    | '>=' | '-' | '+' | '&'
    | '**' | '*'  | '/' | "mod"
    | "rem" | "abs" | "not" )
     '"'
     ;
        
terminal STRING_LITERAL:
      '"' STRING_ELEMENT* '"'
    ;
        
terminal fragment STRING_ELEMENT:
     NONQUOTATION_MARKGRAPHIC_CHARACTER
    ;

terminal fragment NONQUOTATION_MARKGRAPHIC_CHARACTER:
	'\u0020' .. '!' | '#' .. '\u1FFF' // '\uFFFF' //'\u10FFFF' // TODO: Fix unicode
	;

terminal SL_COMMENT:
      "--" NONEND_OFLINE_CHARACTER*
    ;

terminal fragment NONEND_OFLINE_CHARACTER:
	GRAPHIC_CHARACTER
    ;

terminal PV: ';';
terminal DP : ':';
terminal P : '.';
terminal V : ',';
terminal PG : '(';
terminal PD : ')';
terminal ET_COM : '&';
terminal PLUS : '+';
terminal MOINS : '-';
terminal ETOI : '*';
terminal ETOI2 : '**';
terminal SLASH : '/';
terminal QUOTE : "'";
terminal FLECHE : '=>';
terminal BV : '|'|'!';
terminal DPE :':=';
terminal PP : '..';
terminal BOIT : '<>';
terminal EG : '=';
terminal DIFF : '/=';
terminal INF : '<';
terminal INFE : '<=';
terminal SUP : '>';
terminal SUPE : '>=';
terminal CHG : '<<';
terminal CHD : '>>';