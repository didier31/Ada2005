/*
 * generated by Xtext
 */
package org.xtext.ada2005.scoping;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.resource.IContainer;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.IResourceDescription;
import org.eclipse.xtext.resource.IResourceDescriptions;
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.ada2005.adb.CompilationUnit;
import org.xtext.ada2005.adb.DeclarativeBlock;
import org.xtext.ada2005.adb.DeclarativeItem;
import org.xtext.ada2005.adb.PackageBody;
import org.xtext.ada2005.adb.PackageDeclaration;
import org.xtext.ada2005.adb.ProcedureSpecification;
import org.xtext.ada2005.adb.ProperBody;
import org.xtext.ada2005.adb.ProtectedOperationItem;
import org.xtext.ada2005.adb.SeparateSubunit;
import org.xtext.ada2005.adb.TaskBody;
import org.xtext.ada2005.adb.TaskDeclaration;
import org.xtext.ada2005.adb.UseClause;
import org.xtext.ada2005.adb.WithClause;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class AdbScopeProvider extends AbstractDeclarativeScopeProvider {
	
	@Inject ResourceDescriptionsProvider rdp;
	@Inject IContainer.Manager cm;
	
	final Map<Class<? extends EObject>, Class<? extends EObject>> bodiesMapping = new HashMap<Class<? extends EObject>, Class<? extends EObject>>();
	
	public AdbScopeProvider()
	{
		bodiesMapping.put(PackageBody.class, PackageDeclaration.class);
		bodiesMapping.put( ProcedureSpecification.class, ProcedureSpecification.class);
	}
	
	/**
	 * 
	 * @param ctx
	 * @param ref
	 * @return
	 */
	IScope scope_WithClause_importURI(WithClause ctx, EReference ref)
	 {
		IResourceDescriptions index = rdp.getResourceDescriptions(ctx.eResource());
		IResourceDescription rd = index.getResourceDescription(ctx.eResource().getURI());
		List<IContainer> containers = cm.getVisibleContainers(rd, index); 
		Iterable<IEObjectDescription> scope = new LinkedList<IEObjectDescription>();
		for (IContainer container : containers)
		{
			if (scope == null)
			{
			   scope = container.getExportedObjects();
			}
			else
			{
			   scope = Iterables.concat(container.getExportedObjects(), scope);
			}
			   
		}
		return new SimpleScope(scope);
	 }

	/**
	 * 
	 * @param ctx
	 * @param ref
	 * @return
	 */
	IScope scope_UsePackageClause_importedNamespace(UseClause ctx, EReference ref)
	 {
		IResourceDescriptions index = rdp.getResourceDescriptions(ctx.eResource());
		IResourceDescription rd = index.getResourceDescription(ctx.eResource().getURI());
		List<IContainer> containers = cm.getVisibleContainers(rd, index); 
		Iterable<IEObjectDescription> scope = new LinkedList<IEObjectDescription>();
		for (IContainer container : containers)
		{
			if (scope == null)
			{
			   scope = container.getExportedObjects();
			}
			else
			{
			   scope = Iterables.concat(container.getExportedObjects(), scope);
			}
			   
		}
		return new SimpleScope(scope);
	 }
	
	 /**
	  * 
	  * @param ctx
	  * @param ref
	  * @return
	  */
/*	 IScope scope_AcceptStatement_entryName(AcceptStatement ctx, EReference ref)
	 {
		@SuppressWarnings("unchecked")
		TaskBody taskBody = (TaskBody) getDeclarativeUnit(ctx);
		TaskDeclaration taskDecl = taskBody.getId();
		EList<TaskItem> taskItems = taskDecl.getTaskDefinition().getTaskItems();
		Vector<EntryDeclaration> entryDecls = new Vector<EntryDeclaration>(taskItems.size());
		for (TaskItem taskItem : taskItems)
		{
			if(taskItem.getEntryDeclaration() != null)
			{
				entryDecls.add(taskItem.getEntryDeclaration());
			}
		}
		return Scopes.scopeFor(entryDecls);
	 }	 */
	 
	 /**
	  * 
	  * @param td
	  * @param ref
	  * @return
	  */
	 IScope scope_TaskDeclaration_endid(TaskDeclaration td, EReference ref)
	 {
		 Vector<TaskDeclaration> tds = new Vector<TaskDeclaration>(1);
		 tds.add(td);
		 return Scopes.scopeFor(tds);
	 }
	 
	 /**
	  * 
	  * @param ctx
	  * @param ref
	  * @return the scope
	  */
	 IScope scope_TaskBody_id(TaskBody ctx, EReference ref)
	 {
		DeclarativeBlock container = getDeclarativeBlock(ctx);

		EList<DeclarativeItem> declarativesItems = container.getDeclarativeItems();
		List<TaskDeclaration> taskDesclarations = new ArrayList<TaskDeclaration>(declarativesItems.size());
		for (DeclarativeItem di : declarativesItems)
		{
			if (di != null && di instanceof TaskDeclaration)
			{
				taskDesclarations.add((TaskDeclaration) di);
			}
		 }			 
		 return Scopes.scopeFor(taskDesclarations);
	 }

	 /**
	  * 
	  * @param ctx
	  * @param ref
	  * @return
	  */
	 IScope scope_TaskBody_endId(TaskBody ctx, EReference ref)
	 {
		 return scope_TaskBody_id(ctx, ref);
	 }
	 
	 /**
	  * 
	  * @param ctx
	  * @param ref
	  * @return
	  */
	 IScope scope_PackageBody_name(PackageBody ctx, EReference ref)
	 {
		 return null;
	 }
	 
	 /**
	  * Gets the pathname of the declaration's container of @param body.
	  * 
	  * @param body
	  * @return
	  */
	 EObject getContainerPathname(ProperBody body)
	 {
		 /**
		  * @param body may be a separate body
		  * then, gets the SeparateSubunit's field, parentUnitName.
		  */
		 
		 /**
		  * @param body may be a Body.
		  * then, it may be a DeclarativeItem, 
		  * or a Unit, then the 
		  */
		 
		 return null;
	 }
	 
	 /**
	  * Checks if @param body is the Unit of a CompilationUnit
	  * @param body
	  * @return
	  */
	 boolean isCompilationUnit(ProperBody body)
	 {
		 return body.eContainer() instanceof CompilationUnit;
	 }
	 
	 /**
	  * Checks if @param body is the Unit of a SeparateSubunit
	  * @param body
	  * @return
	  */
	 boolean isSeparateSubunit(ProperBody body)
	 {
		 return body.eContainer() instanceof SeparateSubunit; 
	 }

	 /**
	  * Checks if @param body is a DeclarativeItem of a DeclarativeBlock
	  * @param body
	  * @return
	  */
	 boolean isDeclarativeItem(ProperBody body)
	 {
		 return body.eContainer() instanceof DeclarativeBlock; 
	 }
	 
	 /**
	  * Checks if @param body isProtectedOperationItem
	  * @param body
	  * @return
	  */
	 boolean isProtectedOperationItem(ProperBody body)
	 {
		 return body instanceof ProtectedOperationItem;
	 }
	 
	 /**
	  * 
	  * @param o
	  * @param containerClasses
	  * @return Returns the immediate container of  @param o among @param containerClasses
	  */
	 DeclarativeBlock getDeclarativeBlock(EObject o)
	 {
		EObject container = o.eContainer(); 

		if (container == null || container instanceof DeclarativeBlock)
		{
			return (DeclarativeBlock) container;
		}
		else
		{
			return getDeclarativeBlock(container);
		}
	 } 
}
